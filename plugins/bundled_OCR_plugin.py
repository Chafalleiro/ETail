# ==============================================================================
# Bundled OCR Plugin
# Source: C:\vhost\Repositorios\releases\ocr_plugin
# Files included: 7
# Excluded patterns: ['__pycache__', '*.pyc', '__init__.py', 'ocr_modules\\__init__.py', 'ocr_modules\\ui\\__init__.py', 'ocr_modules\\__pycache__', 'ocr_modules\\ui\\__pycache__']
# Generated by OCR Plugin Bundler
# ==============================================================================
# Note: All internal and relative imports have been removed
# ==============================================================================

import sys

# ==============================================================================
# File: ocr_plugin.py
# ==============================================================================

# plugins/ocr_plugin.py
try:
    # Try to import from plugins package (source mode)
    from plugins.etail_plugin import ETailPlugin
except ImportError:
    try:
        # Try direct import (compiled mode)
        from etail_plugin import ETailPlugin
    except ImportError:
        # Fallback: define it here
        from abc import ABC, abstractmethod
        class ETailPlugin(ABC):
            def __init__(self, app):
                self.app = app
                self.name = "Unnamed Plugin"
                self.version = "1.0" 
                self.description = "No description provided"
                self.enabled = False
                
            @abstractmethod
            def setup(self): pass
                
            @abstractmethod 
            def teardown(self): pass

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import pyautogui
import pytesseract
from PIL import Image, ImageTk, ImageEnhance, ImageFilter
import time
import threading
import json
from pathlib import Path
import mss
import mss.tools
import win32gui
import win32ui
import win32con
import win32process
import ctypes
from ctypes import wintypes
from enum import Enum
import numpy as np
import psutil  # You'll need to: pip install psutil

# ==============================================================================
# File: ocr_modules\capture.py
# ==============================================================================

# plugins/ocr_modules/capture.py
from typing import Dict, Any
from typing import List, Tuple, Callable, Optional
from typing import Callable

class CaptureMethod(Enum):
    AUTODETECT = "auto"
    BITBLT = "bitblt"
    PRINTWINDOW = "printwindow"
    PRINTWINDOW_FULL = "printwindow_full"  # PW_RENDERFULLCONTENT
    MSS = "mss"

class WindowCapture:
    def __init__(self):
        self.current_method = CaptureMethod.AUTODETECT
        self.available_methods = list(CaptureMethod)
    
    def set_method(self, method):
        """Set the capture method for a region"""
        if isinstance(method, str):
            method = CaptureMethod(method)
        self.current_method = method
    
    def capture_region(self, hwnd=None, region=None, subregion_bounds=None):
        """
        Capture a window or screen region with optional subregion
        
        Args:
            hwnd: Window handle (for window capture)
            region: dict with 'left', 'top', 'width', 'height' (for screen capture)
            subregion_bounds: tuple (x, y, width, height) relative to window for subregion capture
        """
        if hwnd and subregion_bounds:
            return self._capture_window_subregion(hwnd, subregion_bounds)
        elif hwnd:
            return self._capture_window(hwnd)
        elif region:
            return self._capture_screen_region(region)
        else:
            raise ValueError("Either hwnd or region must be provided")

    def _capture_window_subregion(self, hwnd, subregion_bounds):
        """Capture a subregion of a window using window capture methods"""
        # First capture the entire window
        full_window_image = self._capture_window(hwnd)

        if not full_window_image:
            return None

        # Extract subregion coordinates
        sub_x, sub_y, sub_w, sub_h = subregion_bounds

        # Ensure subregion is within window bounds
        if (sub_x < 0 or sub_y < 0 or 
            sub_x + sub_w > full_window_image.width or 
            sub_y + sub_h > full_window_image.height):
            print(f"Warning: Subregion {subregion_bounds} outside window bounds {full_window_image.size}")
            # Clamp to window bounds
            sub_x = max(0, sub_x)
            sub_y = max(0, sub_y)
            sub_w = min(sub_w, full_window_image.width - sub_x)
            sub_h = min(sub_h, full_window_image.height - sub_y)
    
        # Crop to subregion
        subregion_image = full_window_image.crop((sub_x, sub_y, sub_x + sub_w, sub_y + sub_h))
        return subregion_image    
    
    def _capture_window(self, hwnd):
        """Capture window using selected method"""
        if self.current_method == CaptureMethod.AUTODETECT:
            return self._capture_window_auto(hwnd)
        elif self.current_method == CaptureMethod.BITBLT:
            return self._capture_window_bitblt(hwnd)
        elif self.current_method == CaptureMethod.PRINTWINDOW:
            return self._capture_window_printwindow(hwnd, flags=0)
        elif self.current_method == CaptureMethod.PRINTWINDOW_FULL:
            return self._capture_window_printwindow(hwnd, flags=2)
        elif self.current_method == CaptureMethod.MSS:
            return self._capture_window_mss(hwnd)
    
    def _capture_window_auto(self, hwnd):
        """Auto-detect best method for window"""
        methods_to_try = [
            (CaptureMethod.PRINTWINDOW_FULL, lambda: self._capture_window_printwindow(hwnd, 2)),
            (CaptureMethod.PRINTWINDOW, lambda: self._capture_window_printwindow(hwnd, 0)),
            (CaptureMethod.BITBLT, lambda: self._capture_window_bitblt(hwnd)),
            (CaptureMethod.MSS, lambda: self._capture_window_mss(hwnd)),
        ]
        
        for method_name, capture_func in methods_to_try:
            try:
                result = capture_func()
                print(f"Auto-selected method: {method_name.value}")
                return result
            except Exception as e:
                print(f"Method {method_name.value} failed: {e}")
                continue
        
        raise Exception("All capture methods failed")
    
    def _capture_window_bitblt(self, hwnd):
        """Traditional BitBlt method"""
        left, top, right, bottom = win32gui.GetWindowRect(hwnd)
        width = right - left
        height = bottom - top
        
        hwndDC = win32gui.GetWindowDC(hwnd)
        mfcDC = win32ui.CreateDCFromHandle(hwndDC)
        saveDC = mfcDC.CreateCompatibleDC()
        
        saveBitMap = win32ui.CreateBitmap()
        saveBitMap.CreateCompatibleBitmap(mfcDC, width, height)
        saveDC.SelectObject(saveBitMap)
        
        # Use BitBlt
        saveDC.BitBlt((0, 0), (width, height), mfcDC, (0, 0), win32con.SRCCOPY)
        
        bmpinfo = saveBitMap.GetInfo()
        bmpstr = saveBitMap.GetBitmapBits(True)
        
        im = Image.frombuffer(
            'RGB',
            (bmpinfo['bmWidth'], bmpinfo['bmHeight']),
            bmpstr, 'raw', 'BGRX', 0, 1
        )
        
        # Clean up
        win32gui.DeleteObject(saveBitMap.GetHandle())
        saveDC.DeleteDC()
        mfcDC.DeleteDC()
        win32gui.ReleaseDC(hwnd, hwndDC)
        
        return im
    
    def _capture_window_printwindow(self, hwnd, flags=0):
        """PrintWindow method with configurable flags"""
        left, top, right, bottom = win32gui.GetWindowRect(hwnd)
        width = right - left
        height = bottom - top
        
        hwndDC = win32gui.GetWindowDC(hwnd)
        mfcDC = win32ui.CreateDCFromHandle(hwndDC)
        saveDC = mfcDC.CreateCompatibleDC()
        
        saveBitMap = win32ui.CreateBitmap()
        saveBitMap.CreateCompatibleBitmap(mfcDC, width, height)
        saveDC.SelectObject(saveBitMap)
        
        # Use PrintWindow with flags
        result = win32gui.PrintWindow(hwnd, saveDC.GetSafeHdc(), flags)
        
        if result != 1:
            raise Exception(f"PrintWindow failed with result: {result}")
        
        bmpinfo = saveBitMap.GetInfo()
        bmpstr = saveBitMap.GetBitmapBits(True)
        im = Image.frombuffer(
            'RGB',
            (bmpinfo['bmWidth'], bmpinfo['bmHeight']),
            bmpstr, 'raw', 'BGRX', 0, 1
        )
        
        # Clean up
        win32gui.DeleteObject(saveBitMap.GetHandle())
        saveDC.DeleteDC()
        mfcDC.DeleteDC()
        win32gui.ReleaseDC(hwnd, hwndDC)
        
        return im
    
    def _capture_window_mss(self, hwnd):
        """MSS method for window capture"""
        left, top, right, bottom = win32gui.GetWindowRect(hwnd)
        monitor = {
            "left": left,
            "top": top, 
            "width": right - left,
            "height": bottom - top
        }
        
        with mss.mss() as sct:
            sct_img = sct.grab(monitor)
            return Image.frombytes("RGB", sct_img.size, sct_img.bgra, "raw", "BGRX")
    
    def _capture_screen_region(self, region):
        """Capture screen region (for non-window areas)"""
        if self.current_method == CaptureMethod.MSS:
            with mss.mss() as sct:
                sct_img = sct.grab(region)
                return Image.frombytes("RGB", sct_img.size, sct_img.bgra, "raw", "BGRX")
        else:
            # Fallback to BitBlt for screen regions
            hwnd = win32gui.GetDesktopWindow()
            left, top, width, height = region['left'], region['top'], region['width'], region['height']
            
            hwndDC = win32gui.GetWindowDC(hwnd)
            mfcDC = win32ui.CreateDCFromHandle(hwndDC)
            saveDC = mfcDC.CreateCompatibleDC()
            
            saveBitMap = win32ui.CreateBitmap()
            saveBitMap.CreateCompatibleBitmap(mfcDC, width, height)
            saveDC.SelectObject(saveBitMap)
            
            saveDC.BitBlt((0, 0), (width, height), mfcDC, (left, top), win32con.SRCCOPY)
            
            bmpinfo = saveBitMap.GetInfo()
            bmpstr = saveBitMap.GetBitmapBits(True)
            
            im = Image.frombuffer(
                'RGB',
                (bmpinfo['bmWidth'], bmpinfo['bmHeight']),
                bmpstr, 'raw', 'BGRX', 0, 1
            )
            
            # Clean up
            win32gui.DeleteObject(saveBitMap.GetHandle())
            saveDC.DeleteDC()
            mfcDC.DeleteDC()
            win32gui.ReleaseDC(hwnd, hwndDC)
            
            return im

# from ocr_modules.capture import WindowCapture, CaptureMethod  # internal import removed

# ==============================================================================
# File: ocr_modules\config.py
# ==============================================================================

# plugins/ocr_modules/config.py

class ConfigManager:
    def __init__(self):
        self.config_file = Path("~/.etail/ocr_plugin_config.json").expanduser()
        self.config_file.parent.mkdir(parents=True, exist_ok=True)
        
        # Your default config (copied from main file)
        self.default_config = {
            "tesseract_path": "",
            "check_interval": 2.0,
            "confidence_threshold": 70,
            "language": "eng",
            "ocr_engine_mode": 3,
            "page_segmentation_mode": 6,
            "regions": [],
            "use_mss": True,
            
            # Capture method settings
            "capture_method": "auto",  # Default capture method
            "region_capture_methods": {},  # Per-region capture methods
            
            # Gaming optimization settings
            "enable_preprocessing": True,
            "enable_fuzzy_matching": False,
            "fuzzy_threshold": 85,
            "tts_alerts": False,
            "not_alerts": False,
            "performance_monitoring": True,
            
            # Game-specific OCR profiles
            "game_profiles": {
                "default": {"psm": 6, "oem": 3, "contrast": 1.5, "scale_factor": 1.0},
                "small_text": {"psm": 7, "oem": 3, "contrast": 2.0, "scale_factor": 2.0},
                "console_text": {"psm": 6, "oem": 3, "contrast": 1.8, "scale_factor": 1.5},
                "ui_text": {"psm": 6, "oem": 3, "contrast": 1.3, "scale_factor": 1.0}
            },
            "current_profile": "default",
            
            # COLOR FILTERING SETTINGS
            "enable_color_filtering": True,
            "color_tolerance": 30,
            "color_filters": {
                "default": {
                    "target_colors": [
                        {"r": 255, "g": 255, "b": 255},  # White text
                        {"r": 255, "g": 255, "b": 0},    # Yellow text  
                        {"r": 255, "g": 0, "b": 0},      # Red text
                        {"r": 0, "g": 255, "b": 0}       # Green text
                    ],
                    "invert_after_filter": True
                },
                "dark_text": {
                    "target_colors": [
                        {"r": 0, "g": 0, "b": 0},        # Black text
                        {"r": 50, "g": 50, "b": 50},     # Dark gray
                        {"r": 100, "g": 0, "b": 0}       # Dark red
                    ],
                    "invert_after_filter": False
                }
            },
            "current_color_profile": "default"
        }

        self.config = self.default_config.copy()
        self.load_configuration()
    
    def load_configuration(self):
        try:
            if self.config_file.exists():
                with open(self.config_file, 'r', encoding='utf-8') as f:
                    loaded_config = json.load(f)
                    # Handle nested updates (game_profiles, color_filters)
                    if 'game_profiles' in loaded_config:
                        self.config['game_profiles'].update(loaded_config['game_profiles'])
                        loaded_config.pop('game_profiles', None)
                    if 'color_filters' in loaded_config:
                        self.config['color_filters'].update(loaded_config['color_filters'])
                        loaded_config.pop('color_filters', None)
                    self.config.update(loaded_config)
        except Exception as e:
            print(f"Error loading OCR plugin config: {e}")
    
    def save_configuration(self):
        try:
            # Update regions before saving
            if hasattr(self, 'app') and hasattr(self.app, 'plugins'):
                plugin = self.app.plugins.get('OCRMonitorPlugin')
                if plugin and hasattr(plugin, 'regions'):
                    self.config["regions"] = plugin.regions
                    print(f"DEBUG: Saving {len(plugin.regions)} regions")

            with open(self.config_file, 'w', encoding='utf-8') as f:
                json.dump(self.config, f, indent=2, ensure_ascii=False)
            print(f"? DEBUG: Config saved to {self.config_file}")
        except Exception as e:
            print(f"? DEBUG: Error saving config: {e}")

    def get(self, key, default=None):
        return self.config.get(key, default)
    
    def set(self, key, value):
        self.config[key] = value
        self.save_configuration()
# from ocr_modules.config import ConfigManager  # internal import removed

# ==============================================================================
# File: ocr_modules\region_selector.py
# ==============================================================================

# plugins/ocr_modules/region_selector.py


# Import from our other modules
# from .capture import WindowCapture, CaptureMethod  # internal import removed

class RegionSelector:
    """Visual region selector with proper multi-monitor support and capture methods"""
    
    def __init__(self, app):
        self.app = app
        self.selector_window = None
        self.canvas = None
        self.start_x = None
        self.start_y = None
        self.rect = None
        self.screenshot = None
        self.photo = None
        self.selected_region = None
        self.selected_window = None
        self.monitors = []
        self.capture_manager = WindowCapture()
        self.window_selection_mode = False
        print("DEBUG: RegionSelector methods after init:")
        for attr_name in dir(self):
            if not attr_name.startswith('__'):
                print(f"  - {attr_name}")

    def select_window(self):
        """Select a specific window instead of screen region"""
        try:
            self.window_selection_mode = True
            self.app.root.withdraw()
            
            # Create window selection interface
            selector = tk.Toplevel()
            selector.attributes('-fullscreen', True)
            selector.attributes('-alpha', 0.3)
            selector.attributes('-topmost', True)
            selector.configure(cursor='crosshair')
            selector.configure(bg='blue')
            
            # Instructions
            label = tk.Label(selector, 
                           text="Click on the window you want to capture. Press ESC to cancel.",
                           font=("Arial", 16, "bold"), 
                           bg='blue', fg='white')
            label.place(relx=0.5, rely=0.1, anchor=tk.CENTER)
            
            def on_click(event):
                x, y = event.x_root, event.y_root
                hwnd = win32gui.WindowFromPoint((x, y))
                
                # Get window info
                window_text = win32gui.GetWindowText(hwnd)
                class_name = win32gui.GetClassName(hwnd)
                
                if hwnd and win32gui.IsWindowVisible(hwnd):
                    # Get window rect
                    left, top, right, bottom = win32gui.GetWindowRect(hwnd)
                    width = right - left
                    height = bottom - top
                    
                    # Store window info
                    self.selected_window = {
                        'hwnd': hwnd,
                        'title': window_text,
                        'class_name': class_name,
                        'bounds': (left, top, width, height)
                    }
                    
                    print(f"Selected window: {window_text} (Class: {class_name})")
                    print(f"Window bounds: {left}, {top}, {width}, {height}")
                    
                    selector.destroy()
                    self.app.root.deiconify()
                    
                    # Open window configuration dialog
                    self._configure_window_region()
                else:
                    messagebox.showwarning("Invalid Window", "Please select a valid visible window.")
            
            def cancel_selection(event=None):
                self.selected_window = None
                selector.destroy()
                self.app.root.deiconify()
            
            selector.bind('<Button-1>', on_click)
            selector.bind('<Escape>', cancel_selection)
            selector.focus_force()
            
        except Exception as e:
            print(f"Window selection error: {e}")
            self.app.root.deiconify()

    def _configure_window_region(self):
        """Configure region for a selected window"""
        if not self.selected_window:
            return
            
        dialog = tk.Toplevel(self.app.root)
        dialog.title("Configure Window Capture")
        dialog.geometry("500x400")
        dialog.transient(self.app.root)
        
        main_frame = ttk.Frame(dialog, padding=10)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Window info
        info_frame = ttk.LabelFrame(main_frame, text="Window Information")
        info_frame.pack(fill=tk.X, pady=(0, 10))
        
        info_text = tk.Text(info_frame, height=4, wrap=tk.WORD)
        info_text.pack(fill=tk.X, padx=5, pady=5)
        
        window_info = self.selected_window
        info_text.insert(1.0, 
            f"Window Title: {window_info['title']}\n"
            f"Class: {window_info['class_name']}\n"
            f"Handle: {window_info['hwnd']}\n"
            f"Bounds: {window_info['bounds']}"
        )
        info_text.config(state=tk.DISABLED)
        
        # Region name
        ttk.Label(main_frame, text="Region Name:").pack(anchor=tk.W, pady=(10, 5))
        name_var = tk.StringVar(value=window_info['title'][:30] or f"Window_{window_info['hwnd']}")
        ttk.Entry(main_frame, textvariable=name_var).pack(fill=tk.X, pady=(0, 10))
        
        # Capture method for window
        ttk.Label(main_frame, text="Capture Method:").pack(anchor=tk.W, pady=(0, 5))
        method_var = tk.StringVar(value="auto")
        method_combo = ttk.Combobox(main_frame, textvariable=method_var,
                                  values=[method.value for method in CaptureMethod],
                                  state="readonly")
        method_combo.pack(fill=tk.X, pady=(0, 10))
        
        # Test capture button
        def test_capture():
            try:
                self.capture_manager.set_method(method_var.get())
                image = self.capture_manager.capture_region(hwnd=window_info['hwnd'])
                if image:
                    # Show preview
                    preview = tk.Toplevel(dialog)
                    preview.title("Capture Test")
                    
                    # Resize for preview
                    display_width = min(image.width, 400)
                    scale_factor = display_width / image.width
                    display_height = int(image.height * scale_factor)
                    
                    preview_image = image.resize((display_width, display_height), Image.LANCZOS)
                    photo = ImageTk.PhotoImage(preview_image)
                    
                    label = ttk.Label(preview, image=photo)
                    label.image = photo
                    label.pack(padx=10, pady=10)
                    
                    ttk.Label(preview, text="If you see a black screen, try a different capture method.").pack(pady=5)
                else:
                    messagebox.showerror("Test Failed", "Failed to capture window")
            except Exception as e:
                messagebox.showerror("Test Failed", f"Error: {e}")
        
        ttk.Button(main_frame, text="Test Capture", command=test_capture).pack(anchor=tk.W, pady=(0, 10))
        
        # Patterns (same as before but for window)
        patterns_frame = ttk.LabelFrame(main_frame, text="Patterns to Monitor")
        patterns_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        patterns_text = tk.Text(patterns_frame, height=6)
        patterns_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        patterns_text.insert(1.0, "error\nwarning\nalert\ncritical")
        
        def save_window_region():
            name = name_var.get().strip()
            if not name:
                messagebox.showerror("Error", "Region name is required")
                return
                
            patterns = [p.strip() for p in patterns_text.get(1.0, tk.END).strip().split('\n') if p.strip()]
            if not patterns:
                messagebox.showerror("Error", "At least one pattern is required")
                return
            
            # Pass window info to the plugin
            if hasattr(self.app, 'plugins') and 'OCRMonitorPlugin' in self.app.plugins:
                plugin = self.app.plugins['OCRMonitorPlugin']
                plugin.add_window_region(
                    name=name,
                    hwnd=window_info['hwnd'],
                    window_title=window_info['title'],
                    capture_method=method_var.get(),
                    patterns=patterns,
                    cooldown=300
                )
                
            dialog.destroy()
            self.app.messages(2, 9, f"Window region '{name}' added")
        
        ttk.Button(main_frame, text="Save Window Region", 
                  command=save_window_region, style='Success.TButton').pack(anchor=tk.E)

    def capture_all_monitors(self):
        """Capture screenshot of all monitors combined using WindowCapture"""
        # Make sure we have monitor data
        if not self.monitors:
            self.get_all_monitors()
            
        try:
            # Calculate bounding box that contains all monitors
            all_left = min(monitor['left'] for monitor in self.monitors)
            all_top = min(monitor['top'] for monitor in self.monitors)
            all_right = max(monitor['right'] for monitor in self.monitors)
            all_bottom = max(monitor['bottom'] for monitor in self.monitors)
            
            total_width = all_right - all_left
            total_height = all_bottom - all_top
            
            print(f"DEBUG: Virtual screen bounds: left={all_left}, top={all_top}, right={all_right}, bottom={all_bottom}")
            print(f"DEBUG: Capturing virtual screen: {total_width}x{total_height}")
            
            # Use WindowCapture to capture the region
            region = {
                'left': all_left,
                'top': all_top, 
                'width': total_width,
                'height': total_height
            }
            
            return self.capture_manager.capture_region(region=region)
            
        except Exception as e:
            print(f"Error capturing all monitors: {e}")
            raise
        
    def select_region(self):
        """Open region selector covering all monitors"""
        try:
            # Get monitor information first
            self.get_all_monitors()
            
            # Capture screenshot of all monitors
            self.screenshot = self.capture_all_monitors()
            
            # Calculate virtual screen bounds
            all_left = min(monitor['left'] for monitor in self.monitors)
            all_top = min(monitor['top'] for monitor in self.monitors)
            all_right = max(monitor['right'] for monitor in self.monitors)
            all_bottom = max(monitor['bottom'] for monitor in self.monitors)
            
            total_width = all_right - all_left
            total_height = all_bottom - all_top
            
            # Create fullscreen selection window
            self.selector_window = tk.Toplevel(self.app.root)
            self.selector_window.attributes('-fullscreen', True)
            self.selector_window.attributes('-alpha', 0.7)
            self.selector_window.attributes('-topmost', True)
            self.selector_window.configure(cursor='crosshair')
            self.selector_window.configure(background='black')
            
            # Create canvas covering virtual screen
            self.canvas = tk.Canvas(self.selector_window, 
                                   width=total_width, 
                                   height=total_height,
                                   highlightthickness=0)
            self.canvas.pack(fill=tk.BOTH, expand=True)
            
            # Display screenshot
            self.photo = ImageTk.PhotoImage(self.screenshot)
            self.canvas.create_image(-all_left, -all_top, anchor=tk.NW, image=self.photo)
            
            # Draw monitor boundaries
            self._draw_monitor_boundaries(all_left, all_top)
            
            # Bind mouse events
            self.canvas.bind('<Button-1>', self.on_mouse_down)
            self.canvas.bind('<B1-Motion>', self.on_mouse_drag)
            self.canvas.bind('<ButtonRelease-1>', self.on_mouse_up)
            self.selector_window.bind('<Escape>', self.cancel_selection)
            
            # Instructions
            instructions = self.canvas.create_text(
                total_width // 2, 30,
                text="Drag to select region on any monitor. Press ESC to cancel.",
                fill="white",
                font=("Arial", 14, "bold"),
                justify=tk.CENTER
            )
            self.canvas.tag_raise(instructions)
            
            # Wait for selection
            self.selector_window.wait_window()
            return self.selected_region
            
        except Exception as e:
            print(f"Error in region selection: {e}")
            # Fallback to single monitor
            return self._fallback_select_region()

    def _draw_monitor_boundaries(self, offset_x, offset_y):
        """Draw boundaries around each monitor"""
        for i, monitor in enumerate(self.monitors):
            x1 = monitor['left'] - offset_x
            y1 = monitor['top'] - offset_y
            x2 = x1 + monitor['width']
            y2 = y1 + monitor['height']
            
            # Draw monitor border
            self.canvas.create_rectangle(
                x1, y1, x2, y2,
                outline='yellow', width=3, dash=(5, 5)
            )
            
            # Add monitor label
            monitor_text = f"Monitor {i}"
            if i == 1:  # Monitor 1 is typically the primary
                monitor_text += " (Primary)"
                
            self.canvas.create_text(
                x1 + 10, y1 + 20,
                text=monitor_text,
                fill="yellow",
                font=("Arial", 10, "bold"),
                anchor=tk.W
            )
            
    def _fallback_select_region(self):
        """Fallback method using pyautogui (single monitor only)"""
        print("DEBUG: Using fallback single-monitor selection")
        try:
            self.screenshot = pyautogui.screenshot()
            
            # Create fullscreen selection window
            self.selector_window = tk.Toplevel(self.app.root)
            self.selector_window.attributes('-fullscreen', True)
            self.selector_window.attributes('-alpha', 0.7)
            self.selector_window.attributes('-topmost', True)
            self.selector_window.configure(cursor='crosshair')
            
            screen_width = self.screenshot.width
            screen_height = self.screenshot.height
            
            self.canvas = tk.Canvas(self.selector_window, 
                                   width=screen_width, 
                                   height=screen_height,
                                   highlightthickness=0)
            self.canvas.pack(fill=tk.BOTH, expand=True)
            
            # Display screenshot
            self.photo = ImageTk.PhotoImage(self.screenshot)
            self.canvas.create_image(0, 0, anchor=tk.NW, image=self.photo)
            
            # Bind mouse events
            self.canvas.bind('<Button-1>', self.on_mouse_down)
            self.canvas.bind('<B1-Motion>', self.on_mouse_drag)
            self.canvas.bind('<ButtonRelease-1>', self.on_mouse_up)
            self.selector_window.bind('<Escape>', self.cancel_selection)
            
            # Instructions
            self.canvas.create_text(
                screen_width // 2, 30,
                text="Drag to select region (Single monitor mode). Press ESC to cancel.",
                fill="white",
                font=("Arial", 14, "bold"),
                justify=tk.CENTER
            )
            
            # Wait for selection
            self.selector_window.wait_window()
            return self.selected_region
            
        except Exception as e:
            print(f"Error in fallback region selection: {e}")
            return None
        
    def on_mouse_down(self, event):
        """Start region selection"""
        self.start_x = event.x
        self.start_y = event.y
        self.rect = self.canvas.create_rectangle(
            self.start_x, self.start_y, self.start_x, self.start_y,
            outline='red', width=2, fill='', stipple='gray50'
        )
        
    def on_mouse_drag(self, event):
        """Update selection rectangle"""
        if self.rect:
            self.canvas.coords(self.rect, self.start_x, self.start_y, event.x, event.y)
            
    def on_mouse_up(self, event):
        """Finish region selection"""
        if self.rect:
            # Get final coordinates
            x1, y1, x2, y2 = self.canvas.coords(self.rect)
            
            # Ensure positive width and height
            x = min(x1, x2)
            y = min(y1, y2)
            width = abs(x2 - x1)
            height = abs(y2 - y1)
            
            # Only accept regions larger than 10x10 pixels
            if width > 10 and height > 10:
                # Convert canvas coordinates to screen coordinates
                screen_x, screen_y = self._canvas_to_screen(x, y)
                
                self.selected_region = (int(screen_x), int(screen_y), int(width), int(height))
                
                # Draw final confirmation
                self.canvas.create_rectangle(
                    x, y, x + width, y + height,
                    outline='lime', width=3, fill='', stipple='gray25'
                )
                
                # Add coordinates text
                coords_text = f"Region: {int(screen_x)}, {int(screen_y)}, {int(width)}, {int(height)}"
                self.canvas.create_text(
                    x + width // 2, y + height + 20,
                    text=coords_text,
                    fill="lime",
                    font=("Arial", 10, "bold")
                )
                
                # Determine which monitor this region is on
                monitor_info = self._get_region_monitor(screen_x, screen_y, width, height)
                self.canvas.create_text(
                    x + width // 2, y + height + 40,
                    text=f"On: {monitor_info}",
                    fill="cyan",
                    font=("Arial", 9, "bold")
                )
                
                # Wait a moment so user can see the selection
                self.selector_window.after(1000, self.selector_window.destroy)
            else:
                messagebox.showwarning("Region too small", "Please select a larger region")
                self.cancel_selection()
                
    def _canvas_to_screen(self, canvas_x, canvas_y):
        """Convert canvas coordinates to actual screen coordinates"""
        # For multi-monitor setup with mss, we need to account for the virtual screen offset
        if hasattr(self, 'monitors') and self.monitors:
            all_left = min(monitor['left'] for monitor in self.monitors)
            all_top = min(monitor['top'] for monitor in self.monitors)
            screen_x = canvas_x + all_left
            screen_y = canvas_y + all_top
        else:
            # Fallback for single monitor
            screen_x = canvas_x
            screen_y = canvas_y
            
        return screen_x, screen_y
        
    def _get_region_monitor(self, x, y, width, height):
        """Determine which monitor contains the selected region"""
        region_center_x = x + width // 2
        region_center_y = y + height // 2
        
        for i, monitor in enumerate(self.monitors):
            if (monitor['left'] <= region_center_x <= monitor['right'] and
                monitor['top'] <= region_center_y <= monitor['bottom']):
                monitor_type = "Primary" if i == 1 else f"Monitor {i}"
                return f"{monitor_type} ({monitor['width']}x{monitor['height']})"
                
        return "Unknown Monitor"
                
    def cancel_selection(self, event=None):
        """Cancel region selection"""
        self.selected_region = None
        if self.selector_window:
            self.selector_window.destroy()

    def capture_region_for_preview(self, region_coords):
        """Capture a specific region for preview using configured method"""
        try:
            x, y, width, height = region_coords
            region = {
                'left': x,
                'top': y,
                'width': width,
                'height': height
            }
            return self.capture_manager.capture_region(region=region)
        except Exception as e:
            print(f"Error capturing region for preview: {e}")
            return None

# from ocr_modules.region_selector import RegionSelector  # internal import removed

# ==============================================================================
# File: ocr_modules\ui\ui_components.py
# ==============================================================================

# plugins/ocr_modules/ui_components.py


class PatternTTSDialog:
    """Enhanced dialog for pattern + TTS message configuration"""
    
    def __init__(self, parent, title="Patterns & TTS Messages", default_patterns=None):
        self.parent = parent
        self.title = title
        self.default_patterns = default_patterns or [
            ("error", "Error detected"),
            ("warning", "Warning found"), 
            ("critical", "Critical alert")
        ]
        self.pattern_rows = []
        self.result = None
        
    def show(self):
        """Show dialog and return (patterns, tts_messages) or None if cancelled"""
        dialog = tk.Toplevel(self.parent)
        dialog.title(self.title)
        dialog.geometry("600x450")
        dialog.transient(self.parent)
        dialog.resizable(True, True)
        
        # Center dialog
        dialog.update_idletasks()
        x = (dialog.winfo_screenwidth() // 2) - (600 // 2)
        y = (dialog.winfo_screenheight() // 2) - (450 // 2)
        dialog.geometry(f"600x450+{x}+{y}")
        
        main_frame = ttk.Frame(dialog, padding=15)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Header with instructions
        header_frame = ttk.Frame(main_frame)
        header_frame.pack(fill=tk.X, pady=(0, 15))
        
        ttk.Label(header_frame, text="Configure Patterns & TTS Messages", 
                 font=("Arial", 11, "bold")).pack(anchor=tk.W)
        
        instruction_text = (
            "Add text patterns to monitor and their corresponding TTS messages.\n"
            "Patterns are case-insensitive. Leave TTS blank to use pattern text."
        )
        ttk.Label(header_frame, text=instruction_text, wraplength=500,
                 font=("Arial", 9), foreground="gray").pack(anchor=tk.W, pady=(5, 0))
        
        # Patterns container with scrollbar
        container_frame = ttk.LabelFrame(main_frame, text="Patterns Configuration")
        container_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 15))
        
        # Create canvas and scrollbar
        canvas = tk.Canvas(container_frame, highlightthickness=0)
        scrollbar = ttk.Scrollbar(container_frame, orient=tk.VERTICAL, command=canvas.yview)
        self.scrollable_frame = ttk.Frame(canvas)
        
        self.scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5, pady=5)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y, pady=5)
        
        # Column headers
        headers_frame = ttk.Frame(self.scrollable_frame)
        headers_frame.pack(fill=tk.X, padx=5, pady=(5, 10))
        
        ttk.Label(headers_frame, text="Text Pattern", font=("Arial", 9, "bold")).pack(side=tk.LEFT, padx=(0, 150))
        ttk.Label(headers_frame, text="TTS Message", font=("Arial", 9, "bold")).pack(side=tk.LEFT, padx=(0, 50))
        ttk.Label(headers_frame, text="Actions", font=("Arial", 9, "bold")).pack(side=tk.RIGHT, padx=(0, 10))
        
        # Add default patterns
        for pattern, tts in self.default_patterns:
            self._add_pattern_row(pattern, tts)
        
        # Controls frame (outside scrollable area)
        controls_frame = ttk.Frame(main_frame)
        controls_frame.pack(fill=tk.X, pady=(0, 15))
        
        ttk.Button(controls_frame, text="âž• Add Pattern", 
                  command=self._add_pattern_row).pack(side=tk.LEFT)
        
        # Status label
        self.status_var = tk.StringVar(value=f"{len(self.pattern_rows)} patterns configured")
        status_label = ttk.Label(controls_frame, textvariable=self.status_var, 
                               foreground="gray", font=("Arial", 9))
        status_label.pack(side=tk.RIGHT)
        
        # Dialog buttons
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X)
        
        def on_ok():
            patterns, tts_messages = self._get_current_patterns()
            if not patterns:
                messagebox.showwarning("No Patterns", "Please add at least one pattern to monitor.")
                return
                
            self.result = (patterns, tts_messages)
            dialog.destroy()
        
        def on_cancel():
            self.result = None
            dialog.destroy()
        
        ttk.Button(button_frame, text="OK", 
                  command=on_ok).pack(side=tk.RIGHT, padx=(10, 0))
        ttk.Button(button_frame, text="Cancel", 
                  command=on_cancel).pack(side=tk.RIGHT)
        
        # Bind Enter key to OK and Escape to Cancel
        dialog.bind('<Return>', lambda e: on_ok())
        dialog.bind('<Escape>', lambda e: on_cancel())
        
        # Set focus to first pattern field if empty
        if self.pattern_rows and not self.pattern_rows[0]['pattern_var'].get():
            self.pattern_rows[0]['pattern_entry'].focus()
        
        dialog.wait_window()
        return self.result

    def _add_pattern_row(self, pattern_text="", tts_text=""):
        """Add a new pattern row with improved layout"""
        row_index = len(self.pattern_rows)
        
        # Create frame for this row
        row_frame = ttk.Frame(self.scrollable_frame)
        row_frame.pack(fill=tk.X, padx=5, pady=3)
        
        # Pattern entry (40% width)
        pattern_var = tk.StringVar(value=pattern_text)
        pattern_entry = ttk.Entry(row_frame, textvariable=pattern_var, 
                                 font=("Arial", 9))
        pattern_entry.pack(side=tk.LEFT, padx=(0, 10), fill=tk.X, expand=True)
        
        # TTS entry (50% width)
        tts_var = tk.StringVar(value=tts_text)
        tts_entry = ttk.Entry(row_frame, textvariable=tts_var, 
                             font=("Arial", 9))
        tts_entry.pack(side=tk.LEFT, padx=(0, 10), fill=tk.X, expand=True)
        
        # Remove button (fixed width)
        remove_btn = ttk.Button(row_frame, text="Remove", width=8,
                              command=lambda: self._remove_pattern_row(row_index))
        remove_btn.pack(side=tk.RIGHT)
        
        # Store row data
        row_data = {
            'frame': row_frame,
            'pattern_var': pattern_var,
            'pattern_entry': pattern_entry,
            'tts_var': tts_var,
            'tts_entry': tts_entry,
            'remove_btn': remove_btn
        }
        
        self.pattern_rows.append(row_data)
        self._update_status()

    def _remove_pattern_row(self, row_index):
        """Remove a pattern row"""
        if 0 <= row_index < len(self.pattern_rows):
            # Destroy the row frame
            self.pattern_rows[row_index]['frame'].destroy()
            
            # Remove from list
            self.pattern_rows.pop(row_index)
            
            # Update remove button commands for remaining rows
            for i, row_data in enumerate(self.pattern_rows):
                row_data['remove_btn'].configure(
                    command=lambda r=i: self._remove_pattern_row(r)
                )
            
            self._update_status()

    def _update_status(self):
        """Update status label"""
        pattern_count = len(self.pattern_rows)
        tts_count = sum(1 for row in self.pattern_rows if row['tts_var'].get().strip())
        
        status = f"{pattern_count} pattern(s)"
        if tts_count > 0:
            status += f", {tts_count} with custom TTS"
        
        self.status_var.set(status)

    def _get_current_patterns(self):
        """Get current patterns and TTS messages"""
        patterns = []
        tts_messages = {}
        
        for row_data in self.pattern_rows:
            pattern_text = row_data['pattern_var'].get().strip()
            tts_text = row_data['tts_var'].get().strip()
            
            if pattern_text:  # Only add non-empty patterns
                patterns.append(pattern_text)
                if tts_text and tts_text != pattern_text:  # Only store custom TTS
                    tts_messages[pattern_text] = tts_text
        
        return patterns, tts_messages

class RegionDialog:
    """Enhanced unified dialog for region creation/editing with embedded patterns"""
    
    def __init__(self, parent, title="Region Configuration", 
                 default_name="", default_coords=None,
                 is_edit_mode=False, existing_region=None):
        self.parent = parent
        self.title = title
        self.default_name = default_name
        self.default_coords = default_coords or (100, 100, 400, 200)
        self.is_edit_mode = is_edit_mode
        self.existing_region = existing_region
        self.result = None
        
        # Initialize patterns from existing region or defaults
        if existing_region:
            self.patterns_data = []
            for pattern in existing_region.get('patterns', []):
                tts_msg = existing_region.get('tts_messages', {}).get(pattern, "")
                self.patterns_data.append((pattern, tts_msg))
        else:
            self.patterns_data = [("error", "Error detected")]
        
        # Initialize patterns_status_var here to ensure it exists
        self.patterns_status_var = tk.StringVar(value="0 patterns configured")


    def show(self):
        """Show dialog and return region config or None if cancelled"""
        dialog = tk.Toplevel(self.parent)
        dialog.title(self.title)
        dialog.geometry("700x650")  # Slightly taller to accommodate patterns
        dialog.transient(self.parent)
        dialog.resizable(True, True)
        
        # Center dialog
        dialog.update_idletasks()
        x = (dialog.winfo_screenwidth() // 2) - (700 // 2)
        y = (dialog.winfo_screenheight() // 2) - (650 // 2)
        dialog.geometry(f"700x650+{x}+{y}")
        
        main_frame = ttk.Frame(dialog, padding=10)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Create notebook for tabs
        notebook = ttk.Notebook(main_frame)
        notebook.pack(fill=tk.BOTH, expand=True, pady=(0, 15))
        
        # Basic Settings Tab
        basic_tab = self._create_basic_tab(notebook)
        notebook.add(basic_tab, text="Basic Settings")
        
        # Patterns Tab (now with embedded patterns)
        patterns_tab = self._create_patterns_tab(notebook)
        notebook.add(patterns_tab, text="Patterns & TTS")
        
        # Advanced Tab
        advanced_tab = self._create_advanced_tab(notebook)
        notebook.add(advanced_tab, text="Advanced")
        
        # Dialog buttons
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X)
        
        def on_ok():
            if not self._validate_and_save():
                return
            dialog.destroy()
        
        def on_cancel():
            self.result = None
            dialog.destroy()
        
        ttk.Button(button_frame, text="OK", 
                  command=on_ok).pack(side=tk.RIGHT, padx=(10, 0))
        ttk.Button(button_frame, text="Cancel", 
                  command=on_cancel).pack(side=tk.RIGHT)
        
        # Bind Enter key to OK
        dialog.bind('<Return>', lambda e: on_ok())
        dialog.bind('<Escape>', lambda e: on_cancel())
        
        dialog.wait_window()
        return self.result

    def _create_basic_tab(self, parent):
        """Create basic settings tab with editable coordinates"""
        tab = ttk.Frame(parent, padding=10)

        # Region name
        ttk.Label(tab, text="Region Name:").pack(anchor=tk.W, pady=(0, 5))
        self.name_var = tk.StringVar(value=self.default_name)
        name_entry = ttk.Entry(tab, textvariable=self.name_var)
        name_entry.pack(fill=tk.X, pady=(0, 15))
        name_entry.focus()
    
        # Editable Coordinates
        coords_frame = ttk.LabelFrame(tab, text="Region Coordinates", padding=10)
        coords_frame.pack(fill=tk.X, pady=(0, 15))
    
        # Create grid for coordinate inputs
        coords_grid = ttk.Frame(coords_frame)
        coords_grid.pack(fill=tk.X)
    
        # Labels
        ttk.Label(coords_grid, text="X:").grid(row=0, column=0, padx=(0, 5), pady=2, sticky="w")
        ttk.Label(coords_grid, text="Y:").grid(row=0, column=2, padx=(20, 5), pady=2, sticky="w")
        ttk.Label(coords_grid, text="Width:").grid(row=1, column=0, padx=(0, 5), pady=2, sticky="w")
        ttk.Label(coords_grid, text="Height:").grid(row=1, column=2, padx=(20, 5), pady=2, sticky="w")
    
        # Coordinate entry fields
        x, y, w, h = self.default_coords
    
        self.x_var = tk.StringVar(value=str(x))
        self.y_var = tk.StringVar(value=str(y))
        self.width_var = tk.StringVar(value=str(w))
        self.height_var = tk.StringVar(value=str(h))
    
        x_entry = ttk.Entry(coords_grid, textvariable=self.x_var, width=8)
        y_entry = ttk.Entry(coords_grid, textvariable=self.y_var, width=8)
        width_entry = ttk.Entry(coords_grid, textvariable=self.width_var, width=8)
        height_entry = ttk.Entry(coords_grid, textvariable=self.height_var, width=8)
        
        x_entry.grid(row=0, column=1, padx=(0, 10), pady=2, sticky="w")
        y_entry.grid(row=0, column=3, padx=(0, 10), pady=2, sticky="w")
        width_entry.grid(row=1, column=1, padx=(0, 10), pady=2, sticky="w")
        height_entry.grid(row=1, column=3, padx=(0, 10), pady=2, sticky="w")
    
        # Quick preset buttons
        presets_frame = ttk.Frame(coords_frame)
        presets_frame.pack(fill=tk.X, pady=(10, 0))
    
        ttk.Label(presets_frame, text="Quick presets:").pack(side=tk.LEFT, padx=(0, 10))
    
        def set_preset(width, height):
            self.width_var.set(str(width))
            self.height_var.set(str(height))

        ttk.Button(presets_frame, text="Small (200x100)", command=lambda: set_preset(200, 100)).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(presets_frame, text="Medium (400x200)", command=lambda: set_preset(400, 200)).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(presets_frame, text="Large (600x300)", command=lambda: set_preset(600, 300)).pack(side=tk.LEFT)
    
        # Cooldown setting
        cooldown_frame = ttk.Frame(tab)
        cooldown_frame.pack(fill=tk.X, pady=(0, 10))

        ttk.Label(cooldown_frame, text="Cooldown:").pack(side=tk.LEFT)
        self.cooldown_var = tk.StringVar(
            value=str(self.existing_region.get('cooldown', 300) if self.existing_region else 300)
        )
        cooldown_entry = ttk.Entry(cooldown_frame, textvariable=self.cooldown_var, 
                                width=8)
        cooldown_entry.pack(side=tk.LEFT, padx=(5, 2))
        ttk.Label(cooldown_frame, text="seconds").pack(side=tk.LEFT)
    
        # Enabled checkbox (edit mode only)
        if self.is_edit_mode:
            self.enabled_var = tk.BooleanVar(
                value=self.existing_region.get('enabled', True) if self.existing_region else True
            )
            enabled_cb = ttk.Checkbutton(tab, text="Region Enabled", 
                                    variable=self.enabled_var)
            enabled_cb.pack(anchor=tk.W, pady=(10, 0))
        else:
            self.enabled_var = tk.BooleanVar(value=True)

        return tab

    def _create_patterns_tab(self, parent):
        """Create patterns and TTS configuration tab with embedded pattern management"""
        tab = ttk.Frame(parent, padding=10)
        
        # Instructions
        instruction_text = (
            "Configure text patterns to monitor. Patterns are case-insensitive.\n"
            "Set custom TTS messages or leave blank to use pattern text."
        )
        ttk.Label(tab, text=instruction_text, wraplength=600).pack(anchor=tk.W, pady=(0, 10))
        
        # Patterns container with scrollbar
        container_frame = ttk.LabelFrame(tab, text="Patterns & TTS Messages")
        container_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Create canvas and scrollbar for patterns
        canvas = tk.Canvas(container_frame, highlightthickness=0)
        scrollbar = ttk.Scrollbar(container_frame, orient=tk.VERTICAL, command=canvas.yview)
        self.patterns_scrollable_frame = ttk.Frame(canvas)
        
        self.patterns_scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=self.patterns_scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5, pady=5)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y, pady=5)
        
        # Column headers
        headers_frame = ttk.Frame(self.patterns_scrollable_frame)
        headers_frame.pack(fill=tk.X, padx=5, pady=(5, 10))
        
        ttk.Label(headers_frame, text="Text Pattern", font=("Arial", 9, "bold")).pack(side=tk.LEFT, padx=(0, 120))
        ttk.Label(headers_frame, text="TTS Message", font=("Arial", 9, "bold")).pack(side=tk.LEFT, padx=(0, 50))
        ttk.Label(headers_frame, text="Actions", font=("Arial", 9, "bold")).pack(side=tk.RIGHT, padx=(0, 10))
        
        # Store pattern rows
        self.pattern_rows = []
        
        # Add initial patterns
        for pattern, tts in self.patterns_data:
            self._add_pattern_row(pattern, tts)
        
        # If no patterns, add one empty row
        if not self.patterns_data:
            self._add_pattern_row()
        
        # Update the status with current count
        self._update_patterns_status()
        
        # Controls frame
        controls_frame = ttk.Frame(tab)
        controls_frame.pack(fill=tk.X, pady=(5, 0))
        
        ttk.Button(controls_frame, text="âž• Add Pattern", 
                  command=self._add_pattern_row).pack(side=tk.LEFT)
        
        # Status label - use the already initialized patterns_status_var
        ttk.Label(controls_frame, textvariable=self.patterns_status_var, 
                 foreground="gray", font=("Arial", 9)).pack(side=tk.RIGHT)
        
        return tab

    def _add_pattern_row(self, pattern_text="", tts_text=""):
        """Add a new pattern row"""
        row_index = len(self.pattern_rows)
        
        # Create frame for this row
        row_frame = ttk.Frame(self.patterns_scrollable_frame)
        row_frame.pack(fill=tk.X, padx=5, pady=3)
        
        # Pattern entry
        pattern_var = tk.StringVar(value=pattern_text)
        pattern_entry = ttk.Entry(row_frame, textvariable=pattern_var, 
                                 font=("Arial", 9))
        pattern_entry.pack(side=tk.LEFT, padx=(0, 10), fill=tk.X, expand=True)
        
        # TTS entry
        tts_var = tk.StringVar(value=tts_text)
        tts_entry = ttk.Entry(row_frame, textvariable=tts_var, 
                             font=("Arial", 9))
        tts_entry.pack(side=tk.LEFT, padx=(0, 10), fill=tk.X, expand=True)
        
        # Remove button
        remove_btn = ttk.Button(row_frame, text="Remove", width=8,
                              command=lambda: self._remove_pattern_row(row_index))
        remove_btn.pack(side=tk.RIGHT)
        
        # Store row data
        row_data = {
            'frame': row_frame,
            'pattern_var': pattern_var,
            'tts_var': tts_var,
            'remove_btn': remove_btn
        }
        
        self.pattern_rows.append(row_data)
        self._update_patterns_status()

    def _remove_pattern_row(self, row_index):
        """Remove a pattern row"""
        if 0 <= row_index < len(self.pattern_rows):
            # Destroy the row frame
            self.pattern_rows[row_index]['frame'].destroy()
            
            # Remove from list
            self.pattern_rows.pop(row_index)
            
            # Update remove button commands for remaining rows
            for i, row_data in enumerate(self.pattern_rows):
                row_data['remove_btn'].configure(
                    command=lambda r=i: self._remove_pattern_row(r)
                )
            
            self._update_patterns_status()
            
            # If no patterns left, add one empty row
            if not self.pattern_rows:
                self._add_pattern_row()

    def _update_patterns_status(self):
        """Update patterns status label"""
        pattern_count = len(self.pattern_rows)
        tts_count = sum(1 for row in self.pattern_rows if row['tts_var'].get().strip())
        
        status = f"{pattern_count} pattern(s)"
        if tts_count > 0:
            status += f", {tts_count} with custom TTS"
        
        # This should now work since patterns_status_var is initialized in __init__
        self.patterns_status_var.set(status)

    def _get_current_patterns(self):
        """Get current patterns and TTS messages from embedded rows"""
        patterns = []
        tts_messages = {}
        
        for row_data in self.pattern_rows:
            pattern_text = row_data['pattern_var'].get().strip()
            tts_text = row_data['tts_var'].get().strip()
            
            if pattern_text:  # Only add non-empty patterns
                patterns.append(pattern_text)
                if tts_text and tts_text != pattern_text:  # Only store custom TTS
                    tts_messages[pattern_text] = tts_text
        
        return patterns, tts_messages

    def _create_advanced_tab(self, parent):
        """Create advanced settings tab"""
        tab = ttk.Frame(parent, padding=10)
        
        # Capture method
        ttk.Label(tab, text="Capture Method:").pack(anchor=tk.W, pady=(0, 5))
        self.method_var = tk.StringVar(
            value=self.existing_region.get('capture_method', 'auto') if self.existing_region else 'auto'
        )
        method_combo = ttk.Combobox(tab, textvariable=self.method_var,
                                  values=['auto', 'bitblt', 'printwindow', 'printwindow_full', 'mss'],
                                  state="readonly")
        method_combo.pack(fill=tk.X, pady=(0, 15))
        
        # Method description
        method_descriptions = {
            'auto': 'Automatically select best method',
            'bitblt': 'Fast traditional method',
            'printwindow': 'Works for most applications', 
            'printwindow_full': 'Best for modern apps/games',
            'mss': 'Alternative screen capture'
        }
        method_desc_var = tk.StringVar(value=method_descriptions.get(self.method_var.get(), ""))
        ttk.Label(tab, textvariable=method_desc_var, wraplength=500).pack(anchor=tk.W, pady=(0, 15))
        
        def update_method_desc(*args):
            method_desc_var.set(method_descriptions.get(self.method_var.get(), ""))
        
        self.method_var.trace('w', update_method_desc)
        
        # Color profile
        ttk.Label(tab, text="Color Profile:").pack(anchor=tk.W, pady=(0, 5))
        self.color_var = tk.StringVar(
            value=self.existing_region.get('color_profile', 'default') if self.existing_region else 'default'
        )
        color_combo = ttk.Combobox(tab, textvariable=self.color_var,
                                 values=['default', 'dark_text', 'custom'],
                                 state="readonly")
        color_combo.pack(fill=tk.X, pady=(0, 10))
        
        return tab

    def _validate_and_save(self):
        """Validate inputs and save results"""
        
        # Validate name
        name = self.name_var.get().strip()
        if not name:
            messagebox.showerror("Error", "Region name is required.")
            return False

        # Validate coordinates
        try:
            x = int(self.x_var.get())
            y = int(self.y_var.get())
            width = int(self.width_var.get())
            height = int(self.height_var.get())

            if width <= 0 or height <= 0:
                messagebox.showerror("Error", "Width and height must be positive numbers.")
                return False

            # Optional: Validate that region is within screen bounds
            # You might want to add this check based on your requirements
            # if x < 0 or y < 0:
            #     messagebox.showerror("Error", "Coordinates cannot be negative.")
            #     return False
            
        except ValueError:
            messagebox.showerror("Error", "Coordinates must be valid numbers.")
            return False
    
        # Validate cooldown
        try:
            cooldown = int(self.cooldown_var.get())
            if cooldown < 0:
                messagebox.showerror("Error", "Cooldown must be a positive number.")
                return False
        except ValueError:
            messagebox.showerror("Error", "Cooldown must be a valid number.")
            return False
    
        # Validate patterns
        patterns, tts_messages = self._get_current_patterns()
        if not patterns:
            messagebox.showerror("Error", "At least one pattern is required.")
            return False
    
        # Build result with updated coordinates
        self.result = {
            'name': name,
            'bounds': (x, y, width, height),  # Use the edited coordinates
            'patterns': patterns,
            'tts_messages': tts_messages,
            'cooldown': cooldown,
            'color_profile': self.color_var.get(),
            'enabled': self.enabled_var.get(),
            'capture_method': self.method_var.get()
        }
        print(f"DEBUG: on_ok pressed 276 {self.result}")  # Debug
        return True

class WindowRegionDialog:
    """Unified dialog for window region creation/editing with embedded patterns"""
    
    def __init__(self, parent, title="Window Region Configuration", 
                default_name="", existing_region=None):
        self.parent = parent
        self.title = title
        self.default_name = default_name
        self.existing_region = existing_region
        self.result = None
        self.selected_window = None

        # Initialize patterns from existing region or defaults
        if existing_region:
            self.patterns_data = []
            for pattern in existing_region.get('patterns', []):
                tts_msg = existing_region.get('tts_messages', {}).get(pattern, "")
                self.patterns_data.append((pattern, tts_msg))
        else:
            self.patterns_data = [("error", "Error detected")]
    
        # Initialize ALL Tkinter variables in __init__ to ensure they exist
        self.patterns_status_var = tk.StringVar(value="0 patterns configured")
    
        # Initialize variables that will be used in _set_selected_window
        self.window_title_var = tk.StringVar(value="")
        self.process_name_var = tk.StringVar(value="")
        self.name_var = tk.StringVar(value=default_name)
        self.cooldown_var = tk.StringVar(value="300")
        self.method_var = tk.StringVar(value="auto")
        self.color_var = tk.StringVar(value="default")
        self.enabled_var = tk.BooleanVar(value=True)
    
        # Sub-region data
        self.subregion_bounds = None

    def show(self):
        """Show dialog and return window region config or None if cancelled"""
        dialog = tk.Toplevel(self.parent)
        dialog.title(self.title)
        dialog.geometry("700x650")
        dialog.transient(self.parent)
        dialog.resizable(True, True)
        
        # Center dialog
        dialog.update_idletasks()
        x = (dialog.winfo_screenwidth() // 2) - (700 // 2)
        y = (dialog.winfo_screenheight() // 2) - (650 // 2)
        dialog.geometry(f"700x650+{x}+{y}")
        
        main_frame = ttk.Frame(dialog, padding=10)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Create notebook for tabs
        notebook = ttk.Notebook(main_frame)
        notebook.pack(fill=tk.BOTH, expand=True, pady=(0, 15))
        
        # Window Selection Tab
        window_tab = self._create_window_tab(notebook)
        notebook.add(window_tab, text="Window Selection")
        
        # Patterns Tab (with embedded patterns)
        patterns_tab = self._create_patterns_tab(notebook)
        notebook.add(patterns_tab, text="Patterns & TTS")
        
        # Advanced Tab
        advanced_tab = self._create_advanced_tab(notebook)
        notebook.add(advanced_tab, text="Advanced")
        
        # Dialog buttons
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X)
        
        def on_ok():
            print("DEBUG: on_ok pressed 693")  # Debug        
            if not self._validate_and_save():
                print("DEBUG: on_ok pressed not found validate and save")  # Debug        
                return
            dialog.destroy()
        
        def on_cancel():
            self.result = None
            dialog.destroy()
        
        ttk.Button(button_frame, text="OK", 
                  command=on_ok).pack(side=tk.RIGHT, padx=(10, 0))
        ttk.Button(button_frame, text="Cancel", 
                  command=on_cancel).pack(side=tk.RIGHT)
        
        # Bind Enter key to OK
        dialog.bind('<Return>', lambda e: on_ok())
        dialog.bind('<Escape>', lambda e: on_cancel())
        
        dialog.wait_window()
        return self.result

    def _create_window_tab(self, parent):
        """Create window selection tab with sub-region support"""
        tab = ttk.Frame(parent, padding=10)
    
        # Region name
        ttk.Label(tab, text="Region Name:").pack(anchor=tk.W, pady=(0, 5))
        self.name_var = tk.StringVar(value=self.default_name)
        name_entry = ttk.Entry(tab, textvariable=self.name_var)
        name_entry.pack(fill=tk.X, pady=(0, 15))
        name_entry.focus()
    
        # Window selection section
        window_frame = ttk.LabelFrame(tab, text="Window Selection", padding=10)
        window_frame.pack(fill=tk.X, pady=(0, 15))
    
        # Instructions
        instruction_text = (
            "Select a window to monitor. You can either:\n"
            "â€¢ Pick from a list of available windows, or\n"
            "â€¢ Click on a window directly"
        )
        ttk.Label(window_frame, text=instruction_text, wraplength=600).pack(anchor=tk.W, pady=(0, 10))

        # Selection buttons
        button_frame = ttk.Frame(window_frame)
        button_frame.pack(fill=tk.X, pady=(0, 10))
    
        ttk.Button(button_frame, text="ðŸ“‹ Select from List", 
                command=self._select_from_list).pack(side=tk.LEFT, padx=(0, 10))
        ttk.Button(button_frame, text="ðŸ–±ï¸ Click to Pick", 
                command=self._pick_window_interactive).pack(side=tk.LEFT)
    
        # Selected window info
        self.window_info_frame = ttk.LabelFrame(window_frame, text="Selected Window", padding=10)
        self.window_info_frame.pack(fill=tk.X, pady=(0, 10))
    
        # Initially hidden until window is selected
        self.window_info_label = ttk.Label(self.window_info_frame, text="No window selected")
        self.window_info_label.pack(anchor=tk.W)
    
        # SUB-REGION SECTION - THIS WAS MISSING!
        # Sub-region selection (initially hidden until window is selected)
        self.subregion_frame = ttk.LabelFrame(window_frame, text="Window Sub-Region", padding=10)
        # Don't pack it yet - we'll pack it when a window is selected
    
        self.subregion_info_var = tk.StringVar(value="No sub-region selected (will capture entire window)")
        ttk.Label(self.subregion_frame, textvariable=self.subregion_info_var, 
                wraplength=500).pack(anchor=tk.W, pady=(0, 5))
    
        subregion_buttons = ttk.Frame(self.subregion_frame)
        subregion_buttons.pack(fill=tk.X, pady=(0, 5))
    
        ttk.Button(subregion_buttons, text="ðŸŽ¯ Select Sub-Region", 
                command=self._select_subregion).pack(side=tk.LEFT, padx=(0, 10))
        ttk.Button(subregion_buttons, text="ðŸ—‘ï¸ Clear Sub-Region", 
                command=self._clear_subregion).pack(side=tk.LEFT)
    
        # Test capture button (initially disabled)
        self.test_capture_btn = ttk.Button(window_frame, text="Test Capture", 
                                        command=self._test_window_capture,
                                        state="disabled")
        self.test_capture_btn.pack(anchor=tk.W, pady=(10, 0))
    
        # Cooldown setting
        cooldown_frame = ttk.Frame(tab)
        cooldown_frame.pack(fill=tk.X, pady=(0, 10))
    
        ttk.Label(cooldown_frame, text="Cooldown:").pack(side=tk.LEFT)
        self.cooldown_var = tk.StringVar(
            value=str(self.existing_region.get('cooldown', 300) if self.existing_region else 300)
        )
        cooldown_entry = ttk.Entry(cooldown_frame, textvariable=self.cooldown_var, 
                                width=8)
        cooldown_entry.pack(side=tk.LEFT, padx=(5, 2))
        ttk.Label(cooldown_frame, text="seconds").pack(side=tk.LEFT)
    
        # Enabled checkbox (edit mode only)
        if self.existing_region:
            self.enabled_var = tk.BooleanVar(
                value=self.existing_region.get('enabled', True)
            )
            enabled_cb = ttk.Checkbutton(tab, text="Region Enabled", 
                                    variable=self.enabled_var)
            enabled_cb.pack(anchor=tk.W, pady=(10, 0))
        else:
            self.enabled_var = tk.BooleanVar(value=True)
        
        # Sub-region data
        self.subregion_bounds = None
    
        # Load existing window data if editing
        if self.existing_region and self.existing_region.get('hwnd'):
            self._load_existing_window_data()
    
        return tab
   
    def _select_subregion(self):
        """Select a sub-region within the window"""
        if not self.selected_window:
            messagebox.showwarning("No Window", "Please select a window first.")
            return
    
        try:
            # Hide the dialog temporarily
            self.parent.withdraw()
        
            # Create a region selector instance
#             from ocr_modules.region_selector import RegionSelector  # internal import removed
            selector = RegionSelector(self.parent)
        
        
            # DEBUG: Check the object and methods
            print(f"DEBUG: selector type: {type(selector)}")
            print(f"DEBUG: selector methods: {[m for m in dir(selector) if 'region' in m.lower()]}")
            print(f"DEBUG: has select_region_within_window? {hasattr(selector, 'select_region_within_window')}")
        
            # Get window bounds to constrain selection
            window_bounds = self.selected_window['bounds']
            x, y, width, height = window_bounds
        
            # Select region within the window
            subregion = selector.select_region_within_window(
                self.selected_window['hwnd'], 
                window_bounds
            )
        
            # Show the dialog again
            self.parent.deiconify()
        
            if subregion:
                # Convert to relative coordinates within the window
                sub_x, sub_y, sub_width, sub_height = subregion
                rel_x = sub_x - x
                rel_y = sub_y - y
            
                self.subregion_bounds = (rel_x, rel_y, sub_width, sub_height)
                self._update_subregion_display()
            
                messagebox.showinfo("Sub-Region Selected", 
                                f"Sub-region selected: {sub_width}x{sub_height} at ({rel_x}, {rel_y})")
            else:
                messagebox.showinfo("Cancelled", "Sub-region selection was cancelled.")
            
        except Exception as e:
            self.parent.deiconify()
            messagebox.showerror("Error line 1866", f"1866 Failed to select sub-region: {e}")

    def _clear_subregion(self):
        """Clear the selected sub-region"""
        self.subregion_bounds = None
        self._update_subregion_display()
        messagebox.showinfo("Cleared", "Sub-region cleared. Will capture entire window.")

    def _update_subregion_display(self):
        """Update the sub-region information display"""
        print(f"DEBUG: _update_subregion_display called, subregion_bounds: {self.subregion_bounds}")
    
        if self.subregion_bounds:
            x, y, w, h = self.subregion_bounds
            self.subregion_info_var.set(f"Sub-region selected: {w}x{h} at ({x}, {y})")
            # Make sure the subregion frame is packed and visible
            if not self.subregion_frame.winfo_ismapped():
                print("DEBUG: Packing subregion frame (with subregion)")
                self.subregion_frame.pack(fill=tk.X, pady=(10, 0), before=self.test_capture_btn)
        else:
            self.subregion_info_var.set("No sub-region selected (will capture entire window)")
            # If no subregion, we still want to show the frame but with different text
            if not self.subregion_frame.winfo_ismapped():
                print("DEBUG: Packing subregion frame (no subregion)")
                self.subregion_frame.pack(fill=tk.X, pady=(10, 0), before=self.test_capture_btn)
    
        # Force UI update
        if hasattr(self, 'subregion_frame') and self.subregion_frame.winfo_exists():
            self.subregion_frame.update_idletasks()

    def _create_patterns_tab(self, parent):
        """Create patterns and TTS configuration tab with embedded pattern management"""
        tab = ttk.Frame(parent, padding=10)
        
        # Instructions
        instruction_text = (
            "Configure text patterns to monitor. Patterns are case-insensitive.\n"
            "Set custom TTS messages or leave blank to use pattern text."
        )
        ttk.Label(tab, text=instruction_text, wraplength=600).pack(anchor=tk.W, pady=(0, 10))
        
        # Patterns container with scrollbar
        container_frame = ttk.LabelFrame(tab, text="Patterns & TTS Messages")
        container_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Create canvas and scrollbar for patterns
        canvas = tk.Canvas(container_frame, highlightthickness=0)
        scrollbar = ttk.Scrollbar(container_frame, orient=tk.VERTICAL, command=canvas.yview)
        self.patterns_scrollable_frame = ttk.Frame(canvas)
        
        self.patterns_scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=self.patterns_scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5, pady=5)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y, pady=5)
        
        # Column headers
        headers_frame = ttk.Frame(self.patterns_scrollable_frame)
        headers_frame.pack(fill=tk.X, padx=5, pady=(5, 10))
        
        ttk.Label(headers_frame, text="Text Pattern", font=("Arial", 9, "bold")).pack(side=tk.LEFT, padx=(0, 120))
        ttk.Label(headers_frame, text="TTS Message", font=("Arial", 9, "bold")).pack(side=tk.LEFT, padx=(0, 50))
        ttk.Label(headers_frame, text="Actions", font=("Arial", 9, "bold")).pack(side=tk.RIGHT, padx=(0, 10))
        
        # Store pattern rows
        self.pattern_rows = []
        
        # Add initial patterns
        for pattern, tts in self.patterns_data:
            self._add_pattern_row(pattern, tts)
        
        # If no patterns, add one empty row
        if not self.patterns_data:
            self._add_pattern_row()
        
        # Update the status with current count
        self._update_patterns_status()
        
        # Controls frame
        controls_frame = ttk.Frame(tab)
        controls_frame.pack(fill=tk.X, pady=(5, 0))
        
        ttk.Button(controls_frame, text="âž• Add Pattern", 
                  command=self._add_pattern_row).pack(side=tk.LEFT)
        
        # Status label - use the already initialized patterns_status_var
        ttk.Label(controls_frame, textvariable=self.patterns_status_var, 
                 foreground="gray", font=("Arial", 9)).pack(side=tk.RIGHT)
        
        return tab

    def _create_advanced_tab(self, parent):
        """Create advanced settings tab"""
        tab = ttk.Frame(parent, padding=10)
        
        # Capture method
        ttk.Label(tab, text="Capture Method:").pack(anchor=tk.W, pady=(0, 5))
        self.method_var = tk.StringVar(
            value=self.existing_region.get('capture_method', 'auto') if self.existing_region else 'auto'
        )
        method_combo = ttk.Combobox(tab, textvariable=self.method_var,
                                  values=['auto', 'bitblt', 'printwindow', 'printwindow_full', 'mss'],
                                  state="readonly")
        method_combo.pack(fill=tk.X, pady=(0, 15))
        
        # Method description
        method_descriptions = {
            'auto': 'Automatically select best method for windows',
            'bitblt': 'Fast traditional method - may not work for all windows',
            'printwindow': 'PrintWindow API - works for most windows', 
            'printwindow_full': 'PrintWindow with full content - best for modern apps',
            'mss': 'MSS library - alternative method'
        }
        method_desc_var = tk.StringVar(value=method_descriptions.get(self.method_var.get(), ""))
        ttk.Label(tab, textvariable=method_desc_var, wraplength=500).pack(anchor=tk.W, pady=(0, 15))
        
        def update_method_desc(*args):
            method_desc_var.set(method_descriptions.get(self.method_var.get(), ""))
        
        self.method_var.trace('w', update_method_desc)
        
        # Color profile
        ttk.Label(tab, text="Color Profile:").pack(anchor=tk.W, pady=(0, 5))
        self.color_var = tk.StringVar(
            value=self.existing_region.get('color_profile', 'default') if self.existing_region else 'default'
        )
        color_combo = ttk.Combobox(tab, textvariable=self.color_var,
                                 values=['default', 'dark_text', 'custom'],
                                 state="readonly")
        color_combo.pack(fill=tk.X, pady=(0, 10))
        
        # Window identification criteria (for advanced users)
        criteria_frame = ttk.LabelFrame(tab, text="Window Identification (Advanced)", padding=10)
        criteria_frame.pack(fill=tk.X, pady=(10, 0))
        
        ttk.Label(criteria_frame, text="Window Title:").pack(anchor=tk.W, pady=(0, 5))
        self.window_title_var = tk.StringVar(value=self.existing_region.get('window_title', '') if self.existing_region else '')
        window_title_entry = ttk.Entry(criteria_frame, textvariable=self.window_title_var)
        window_title_entry.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(criteria_frame, text="Process Name:").pack(anchor=tk.W, pady=(0, 5))
        self.process_name_var = tk.StringVar(value=self.existing_region.get('process_name', '') if self.existing_region else '')
        process_name_entry = ttk.Entry(criteria_frame, textvariable=self.process_name_var)
        process_name_entry.pack(fill=tk.X, pady=(0, 10))
        
        info_text = "These fields help identify the window if it moves or restarts.\nThey are automatically filled when you select a window."
        ttk.Label(criteria_frame, text=info_text, wraplength=500, 
                 font=("Arial", 8), foreground="gray").pack(anchor=tk.W)
        
        return tab

    def _select_from_list(self):
        """Open window selection list dialog"""
        try:
            # Import here to avoid circular imports
#             from ocr_plugin import OCRMonitorPlugin  # internal import removed

            # Create a minimal plugin instance just for window listing
            class TempPlugin:
                def __init__(self):
                    self.regions = []

                def list_available_windows(self):
                    import psutil
                    import win32gui
                    import win32process

                    windows = []
                    def enum_windows_proc(hwnd, lParam):
                        if win32gui.IsWindowVisible(hwnd) and win32gui.GetWindowText(hwnd):
                            _, pid = win32process.GetWindowThreadProcessId(hwnd)
                            try:
                                process = psutil.Process(pid)
                                process_name = process.name()
                            except:
                                process_name = "Unknown"

                            window_title = win32gui.GetWindowText(hwnd)
                            class_name = win32gui.GetClassName(hwnd)

                            try:
                                left, top, right, bottom = win32gui.GetWindowRect(hwnd)
                                width = right - left
                                height = bottom - top

                                if width > 100 and height > 100:
                                    windows.append({
                                        'hwnd': hwnd,
                                        'title': window_title,
                                        'class_name': class_name,
                                        'pid': pid,
                                        'process_name': process_name,
                                        'bounds': (left, top, width, height),
                                        'size': f"{width}x{height}"
                                    })
                            except:
                                pass
                        return True

                    win32gui.EnumWindows(enum_windows_proc, None)
                    return sorted(windows, key=lambda x: x['title'])
        
            temp_plugin = TempPlugin()
            windows = temp_plugin.list_available_windows()
        
            if not windows:
                messagebox.showinfo("No Windows", "No suitable windows found.")
                return
        
            # Create selection dialog
            list_dialog = tk.Toplevel(self.parent)
            list_dialog.title("Select Window")
            list_dialog.geometry("700x500")
            list_dialog.transient(self.parent)
            list_dialog.grab_set()  # Make it modal

            main_frame = ttk.Frame(list_dialog, padding=10)
            main_frame.pack(fill=tk.BOTH, expand=True)

            # Instructions
            ttk.Label(main_frame, text="Select a window from the list below:").pack(anchor=tk.W, pady=(0, 10))
        
            # Treeview for windows
            tree_frame = ttk.Frame(main_frame)
            tree_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
            columns = ('title', 'process', 'size')
            tree = ttk.Treeview(tree_frame, columns=columns, show='headings', height=15)
        
            tree.heading('title', text='Window Title')
            tree.heading('process', text='Process')
            tree.heading('size', text='Size')
        
            tree.column('title', width=400)
            tree.column('process', width=150)
            tree.column('size', width=80)

            scrollbar = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL, command=tree.yview)
            tree.configure(yscrollcommand=scrollbar.set)

            tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
            # Store window data in a dictionary for easy lookup
            self.window_data_map = {}

            # Populate treeview
            for win in windows:
                item_id = tree.insert('', tk.END, values=(
                    win['title'][:80] + "..." if len(win['title']) > 80 else win['title'],
                    win['process_name'],
                    win['size']
                ), tags=(win['hwnd'],))
                # Store the window data using the item ID as key
                self.window_data_map[item_id] = win

            def on_select():
                selection = tree.selection()
                if selection:
                    try:
                        item_id = selection[0]  # Get the selected item ID
                        window_data = self.window_data_map.get(item_id)

                        if window_data:
                            self._set_selected_window(window_data)
                            list_dialog.destroy()
                        else:
                            messagebox.showerror("Error", "Could not find selected window data.")
                    except Exception as e:
                        messagebox.showerror("Error", f"Error selecting window: {e}")
                        import traceback
                        traceback.print_exc()  # Print full traceback for debugging
                else:
                    messagebox.showwarning("No Selection", "Please select a window from the list.")        

            def on_cancel():
                list_dialog.destroy()
        
            # Button frame
            button_frame = ttk.Frame(main_frame)
            button_frame.pack(fill=tk.X)
        
            ttk.Button(button_frame, text="Select", 
                    command=on_select).pack(side=tk.RIGHT, padx=(10, 0))
            ttk.Button(button_frame, text="Cancel", 
                    command=on_cancel).pack(side=tk.RIGHT)

            # Double-click to select
            tree.bind('<Double-1>', lambda e: on_select())

            # Set focus to tree and select first item
            tree.focus_set()
            if tree.get_children():
                tree.selection_set(tree.get_children()[0])
                tree.focus(tree.get_children()[0])
        
            # Wait for the list dialog to close
            list_dialog.wait_window()
       
        except Exception as e:
            messagebox.showerror("Error", f"Failed to list windows: {e}")

    def _pick_window_interactive(self):
        """Pick window by clicking on it"""
        try:
#             from ocr_modules.region_selector import RegionSelector  # internal import removed
        
            # Create a simple region selector instance
            selector = RegionSelector(self.parent)
            window_info = selector.select_window()

            if window_info and 'hwnd' in window_info:
                # Convert to the format expected by _set_selected_window
                import win32gui
                import win32process
                import psutil

                hwnd = window_info['hwnd']
                try:
                    _, pid = win32process.GetWindowThreadProcessId(hwnd)
                    try:
                        process = psutil.Process(pid)
                        process_name = process.name()
                    except:
                        process_name = "Unknown"

                    window_title = win32gui.GetWindowText(hwnd)
                    left, top, right, bottom = win32gui.GetWindowRect(hwnd)
                    width = right - left
                    height = bottom - top

                    window_data = {
                        'hwnd': hwnd,
                        'title': window_title,
                        'process_name': process_name,
                        'bounds': (left, top, width, height)
                    }
                    self._set_selected_window(window_data)
                except Exception as e:
                    messagebox.showerror("Error", f"Failed to get window information: {e}")
            else:
                messagebox.showinfo("Cancelled", "Window selection was cancelled.")

        except Exception as e:
            messagebox.showerror("Error", f"Window selection failed: {e}")

    def _set_selected_window(self, window_data):
        """Set the selected window and update UI"""
        print(f"DEBUG: _set_selected_window called with: {window_data['title']}")
        self.selected_window = window_data

        # Update window info display
        for widget in self.window_info_frame.winfo_children():
            widget.destroy()
    
        info_text = f"""Window Title: {window_data['title']}
                    Process: {window_data['process_name']}
                    Size: {window_data['bounds'][2]} x {window_data['bounds'][3]}
                    Handle: {hex(window_data['hwnd'])}"""

        ttk.Label(self.window_info_frame, text=info_text, justify=tk.LEFT).pack(anchor=tk.W)

        # Make sure the window info frame is visible
        self.window_info_frame.pack(fill=tk.X, pady=(0, 10))

        # Enable test button
        self.test_capture_btn.config(state="normal")

        # Auto-fill identification criteria
        self.window_title_var.set(window_data['title'])
        self.process_name_var.set(window_data['process_name'])

        # Auto-generate name if not set
        current_name = self.name_var.get().strip()
        if not current_name or current_name.startswith("Window_"):
            safe_title = "".join(c for c in window_data['title'][:30] if c.isalnum() or c in (' ', '-', '_'))
            if safe_title.strip():
                self.name_var.set(safe_title.strip())
            else:
                self.name_var.set(f"Window_{window_data['process_name']}")

        print(f"DEBUG: Window set successfully: {window_data['title']}")

        # Load existing subregion if editing
        if self.existing_region and self.existing_region.get('subregion_bounds'):
            self.subregion_bounds = self.existing_region['subregion_bounds']
    
        # Update subregion display - THIS ENSURES THE SUBREGION UI IS VISIBLE
        self._update_subregion_display()

        # Force UI update
        self.window_info_frame.update_idletasks()
    
    def _load_existing_window_data(self):
        """Load existing window data when editing"""
        if self.existing_region and self.existing_region.get('hwnd'):
            window_data = {
                'hwnd': self.existing_region.get('hwnd'),
                'title': self.existing_region.get('window_title', 'Unknown'),
                'process_name': self.existing_region.get('process_name', 'Unknown'),
                'bounds': self.existing_region.get('bounds', (0, 0, 100, 100))
            }
            self._set_selected_window(window_data)
            # Load subregion bounds if they exist
            if 'subregion_bounds' in self.existing_region:
                self.subregion_bounds = self.existing_region['subregion_bounds']
                print(f"DEBUG: Loaded existing subregion: {self.subregion_bounds}")  # Debug
            else:
                self.subregion_bounds = None
                print("DEBUG: No existing subregion found")  # Debug
        
            # CRITICAL: Update the subregion display to show existing subregion
            self._update_subregion_display()
        
            # Also make sure the subregion controls are visible
            if not self.subregion_frame.winfo_ismapped():
                self.subregion_frame.pack(fill=tk.X, pady=(10, 0), before=self.test_capture_btn)

    def _test_window_capture(self):
        """Test capture on the selected window"""
        if not self.selected_window:
            messagebox.showwarning("No Window", "Please select a window first.")
            return
        
        try:
#             from ocr_plugin import OCRMonitorPlugin  # internal import removed
            temp_plugin = OCRMonitorPlugin(None)
            temp_plugin.window_capture.set_method(self.method_var.get())
            
            image = temp_plugin.window_capture.capture_region(hwnd=self.selected_window['hwnd'])
            
            if image:
                # Show preview
                preview = tk.Toplevel(self.parent)
                preview.title("Window Capture Test")
                
                from PIL import ImageTk
                display_width = min(image.width, 500)
                scale_factor = display_width / image.width
                display_height = int(image.height * scale_factor)
                
                display_image = image.resize((display_width, display_height))
                photo = ImageTk.PhotoImage(display_image)
                
                label = ttk.Label(preview, image=photo)
                label.image = photo
                label.pack(padx=10, pady=10)
                
                status = "âœ“ Capture successful!"
                if image.getbbox() is None:
                    status = "âš  Warning: Image appears blank. Try a different capture method."
                
                ttk.Label(preview, text=status).pack(pady=5)
                ttk.Label(preview, text=f"Size: {image.width} x {image.height}").pack(pady=5)
            else:
                messagebox.showerror("Test Failed", "Could not capture window. Try a different capture method.")
                
        except Exception as e:
            messagebox.showerror("Test Failed", f"Error: {str(e)}")

    # Pattern management methods (same as in RegionDialog)
    def _add_pattern_row(self, pattern_text="", tts_text=""):
        """Add a new pattern row"""
        row_index = len(self.pattern_rows)
        
        # Create frame for this row
        row_frame = ttk.Frame(self.patterns_scrollable_frame)
        row_frame.pack(fill=tk.X, padx=5, pady=3)
        
        # Pattern entry
        pattern_var = tk.StringVar(value=pattern_text)
        pattern_entry = ttk.Entry(row_frame, textvariable=pattern_var, 
                                 font=("Arial", 9))
        pattern_entry.pack(side=tk.LEFT, padx=(0, 10), fill=tk.X, expand=True)
        
        # TTS entry
        tts_var = tk.StringVar(value=tts_text)
        tts_entry = ttk.Entry(row_frame, textvariable=tts_var, 
                             font=("Arial", 9))
        tts_entry.pack(side=tk.LEFT, padx=(0, 10), fill=tk.X, expand=True)
        
        # Remove button
        remove_btn = ttk.Button(row_frame, text="Remove", width=8,
                              command=lambda: self._remove_pattern_row(row_index))
        remove_btn.pack(side=tk.RIGHT)
        
        # Store row data
        row_data = {
            'frame': row_frame,
            'pattern_var': pattern_var,
            'tts_var': tts_var,
            'remove_btn': remove_btn
        }
        
        self.pattern_rows.append(row_data)
        self._update_patterns_status()

    def _remove_pattern_row(self, row_index):
        """Remove a pattern row"""
        if 0 <= row_index < len(self.pattern_rows):
            # Destroy the row frame
            self.pattern_rows[row_index]['frame'].destroy()
            
            # Remove from list
            self.pattern_rows.pop(row_index)
            
            # Update remove button commands for remaining rows
            for i, row_data in enumerate(self.pattern_rows):
                row_data['remove_btn'].configure(
                    command=lambda r=i: self._remove_pattern_row(r)
                )
            
            self._update_patterns_status()
            
            # If no patterns left, add one empty row
            if not self.pattern_rows:
                self._add_pattern_row()

    def _update_patterns_status(self):
        """Update patterns status label"""
        pattern_count = len(self.pattern_rows)
        tts_count = sum(1 for row in self.pattern_rows if row['tts_var'].get().strip())
        
        status = f"{pattern_count} pattern(s)"
        if tts_count > 0:
            status += f", {tts_count} with custom TTS"
        
        self.patterns_status_var.set(status)

    def _get_current_patterns(self):
        """Get current patterns and TTS messages from embedded rows"""
        patterns = []
        tts_messages = {}
        
        for row_data in self.pattern_rows:
            pattern_text = row_data['pattern_var'].get().strip()
            tts_text = row_data['tts_var'].get().strip()
            
            if pattern_text:  # Only add non-empty patterns
                patterns.append(pattern_text)
                if tts_text and tts_text != pattern_text:  # Only store custom TTS
                    tts_messages[pattern_text] = tts_text
        
        return patterns, tts_messages

    def _validate_and_save(self):
        """Validate inputs and save results"""
        # Validate name
        name = self.name_var.get().strip()
        if not name:
            messagebox.showerror("Error", "Region name is required.")
            return False
    
        # Validate window selection
        if not self.selected_window and not self.existing_region:
            messagebox.showerror("Error", "Please select a window to monitor.")
            return False
    
        # Validate cooldown
        try:
            cooldown = int(self.cooldown_var.get())
            if cooldown < 0:
                messagebox.showerror("Error", "Cooldown must be a positive number.")
                return False
        except ValueError:
            messagebox.showerror("Error", "Cooldown must be a valid number.")
            return False
    
        # Validate patterns
        patterns, tts_messages = self._get_current_patterns()
        if not patterns:
            messagebox.showerror("Error", "At least one pattern is required.")
            return False
    
        # Build result
        self.result = {
            'name': name,
            'type': 'window',
            'hwnd': self.selected_window['hwnd'] if self.selected_window else self.existing_region.get('hwnd'),
            'window_title': self.window_title_var.get() or (self.selected_window['title'] if self.selected_window else ''),
            'process_name': self.process_name_var.get() or (self.selected_window['process_name'] if self.selected_window else ''),
            'bounds': self.selected_window['bounds'] if self.selected_window else self.existing_region.get('bounds', (0, 0, 100, 100)),
            'patterns': patterns,
            'tts_messages': tts_messages,
            'cooldown': cooldown,
            'color_profile': self.color_var.get(),
            'enabled': self.enabled_var.get(),
            'capture_method': self.method_var.get(),
            'subregion_bounds': self.subregion_bounds  # Add the subregion bounds
        }
    
        return True

class RegionTestDialog:
    """Reusable dialog for testing regions with capture methods"""
    
    def __init__(self, parent, plugin, region):
        self.parent = parent
        self.plugin = plugin
        self.region = region
        self.live_preview_active = False

# from ocr_modules.ui.ui_components import PatternTTSDialog  # internal import removed

# ==============================================================================
# File: ocr_modules\ui\settings_tabs.py
# ==============================================================================

# plugins/ocr_modules/ui/settings_tabs.py


class SettingsTabs:
    """Container for all settings tab creation methods"""
    
    def __init__(self, plugin):
        self.plugin = plugin
    
    def create_tesseract_tab(self, parent):
        """Create Tesseract configuration tab"""
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Tesseract path section
        path_frame = ttk.LabelFrame(main_frame, text="Tesseract Configuration")
        path_frame.pack(fill=tk.X, pady=(0, 15))

        inner_frame = ttk.Frame(path_frame)
        inner_frame.pack(fill=tk.X, padx=10, pady=10)

        ttk.Label(inner_frame, text="Tesseract Path:").grid(row=0, column=0, sticky="w", pady=5)

        path_entry_frame = ttk.Frame(inner_frame)
        path_entry_frame.grid(row=1, column=0, columnspan=2, sticky="ew", pady=5)
        path_entry_frame.columnconfigure(0, weight=1)

        self.plugin.tesseract_path_var = tk.StringVar(value=self.plugin.config.get("tesseract_path", ""))
        path_entry = ttk.Entry(path_entry_frame, textvariable=self.plugin.tesseract_path_var, width=50)
        path_entry.grid(row=1, column=0, columnspan=4, sticky="ew", padx=(0, 5))

        ttk.Button(path_entry_frame, text="Browse", 
                  command=self.plugin._browse_tesseract, width=10).grid(row=1, column=5)

        # Test button and status
        ttk.Button(path_entry_frame, text="Test Tesseract", 
                  command=self.plugin._test_tesseract).grid(row=2, column=0)

        self.plugin.tesseract_status_var = tk.StringVar(value="Click 'Test Tesseract' to verify")
        ttk.Label(inner_frame, textvariable=self.plugin.tesseract_status_var).grid(row=2, column=0)

        return main_frame

    def create_ocr_tab(self, parent):
        """Create OCR settings tab using helper methods"""
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Use the plugin's UI helper methods
        self.plugin.interval_var = self.plugin.create_labeled_entry(
            main_frame, "Check Interval (seconds):", 
            str(self.plugin.config.get("check_interval", 2.0))
        )
        
        self.plugin.language_var, _ = self.plugin.create_labeled_combobox(
            main_frame, "OCR Language:",
            ["eng", "spa", "fra", "deu", "ita", "por"],
            self.plugin.config.get("language", "eng")
        )
        
        self.plugin.cooldown_var = self.plugin.create_labeled_entry(
            main_frame, "Default Cooldown (seconds):",
            str(self.plugin.config.get("default_cooldown", 300))
        )
        
        self.plugin.tts_alerts_var = self.plugin.create_checkbox(
            main_frame, "Enable TTS Alerts",
            self.plugin.config.get("tts_alerts", False)
        )

        self.plugin.not_alerts_var = self.plugin.create_checkbox(
            main_frame, "Enable notification Alerts",
            self.plugin.config.get("not_alerts", False)
        )
        
        ttk.Button(main_frame, text="Apply Settings", 
                  command=self.plugin._apply_ocr_settings, 
                  style='Success.TButton').pack(anchor=tk.W, pady=(20, 0))
        
        return main_frame

    def create_gaming_tab(self, parent):
        """Create gaming optimization settings tab"""
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Profile selection
        profile_frame = ttk.LabelFrame(main_frame, text="Game Text Profile")
        profile_frame.pack(fill=tk.X, pady=(0, 15))

        inner_profile = ttk.Frame(profile_frame)
        inner_profile.pack(fill=tk.X, padx=10, pady=10)

        ttk.Label(inner_profile, text="Profile:").grid(row=0, column=0, sticky="w", pady=5)

        self.plugin.profile_var = tk.StringVar(value=self.plugin.config.get("current_profile", "default"))
        profile_combo = ttk.Combobox(inner_profile, textvariable=self.plugin.profile_var, 
                                    values=list(self.plugin.config["game_profiles"].keys()),
                                    state="readonly", width=20)
        profile_combo.grid(row=0, column=1, sticky="w", padx=(10, 0), pady=5)

        # Profile descriptions
        desc_text = (
            "â€¢ Default: Balanced settings\n"
            "â€¢ Small Text: 2x scale, high contrast\n" 
            "â€¢ Console Text: 1.5x scale, medium contrast\n"
            "â€¢ UI Text: No scaling, low contrast"
        )
        desc_label = ttk.Label(inner_profile, text=desc_text, justify=tk.LEFT)
        desc_label.grid(row=1, column=0, columnspan=2, sticky="w", pady=10)

        # Optimization settings
        optim_frame = ttk.LabelFrame(main_frame, text="Optimization Settings")
        optim_frame.pack(fill=tk.X, pady=(0, 15))

        inner_optim = ttk.Frame(optim_frame)
        inner_optim.pack(fill=tk.X, padx=10, pady=10)

        self.plugin.preprocess_var = tk.BooleanVar(value=self.plugin.config.get("enable_preprocessing", True))
        ttk.Checkbutton(inner_optim, text="Enable Image Pre-processing", 
                    variable=self.plugin.preprocess_var).pack(anchor="w", pady=2)

        self.plugin.fuzzy_var = tk.BooleanVar(value=self.plugin.config.get("enable_fuzzy_matching", False))
        ttk.Checkbutton(inner_optim, text="Enable Fuzzy Text Matching", 
                    variable=self.plugin.fuzzy_var).pack(anchor="w", pady=2)

        # Fuzzy threshold
        fuzzy_frame = ttk.Frame(inner_optim)
        fuzzy_frame.pack(fill=tk.X, pady=5)

        ttk.Label(fuzzy_frame, text="Fuzzy Threshold:").pack(side=tk.LEFT)
        self.plugin.fuzzy_threshold_var = tk.StringVar(value=str(self.plugin.config.get("fuzzy_threshold", 85)))
        ttk.Entry(fuzzy_frame, textvariable=self.plugin.fuzzy_threshold_var, width=5).pack(side=tk.LEFT, padx=(5, 2))
        ttk.Label(fuzzy_frame, text="%").pack(side=tk.LEFT)

        # Performance monitoring
        self.plugin.performance_var = tk.BooleanVar(value=self.plugin.config.get("performance_monitoring", True))
        ttk.Checkbutton(inner_optim, text="Enable Performance Monitoring", 
                    variable=self.plugin.performance_var).pack(anchor="w", pady=2)

        # Performance stats
        stats_frame = ttk.LabelFrame(main_frame, text="Performance Statistics")
        stats_frame.pack(fill=tk.X, pady=(0, 15))

        self.plugin.stats_var = tk.StringVar(value="Run monitor to collect stats")
        stats_label = ttk.Label(stats_frame, textvariable=self.plugin.stats_var, font=("Courier", 9))
        stats_label.pack(padx=10, pady=10)

        # Apply button
        ttk.Button(main_frame, text="Apply Gaming Settings", 
                command=self.plugin._apply_gaming_settings, 
                style='Success.TButton').pack(anchor="e", pady=(10, 0))

        # Update stats display
        self.plugin._update_performance_stats()
    
        return main_frame

    def create_colors_tab(self, parent):
        """Create color filtering settings tab"""
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Enable color filtering
        self.plugin.color_filter_var = tk.BooleanVar(value=self.plugin.config.get("enable_color_filtering", True))
        ttk.Checkbutton(main_frame, text="Enable Color Filtering", 
                    variable=self.plugin.color_filter_var).pack(anchor=tk.W, pady=(0, 15))

        # Color profile selection
        ttk.Label(main_frame, text="Default Color Profile:").pack(anchor=tk.W, pady=(0, 5))
        self.plugin.color_profile_var = tk.StringVar(value=self.plugin.config.get("current_color_profile", "default"))
        color_profiles = list(self.plugin.config["color_filters"].keys())
        color_combo = ttk.Combobox(main_frame, textvariable=self.plugin.color_profile_var, 
                                values=color_profiles, state="readonly")
        color_combo.pack(fill=tk.X, pady=(0, 15))

        # Color tolerance
        tolerance_frame = ttk.Frame(main_frame)
        tolerance_frame.pack(fill=tk.X, pady=(0, 15))
        ttk.Label(tolerance_frame, text="Color Tolerance:").pack(side=tk.LEFT)
        self.plugin.tolerance_var = tk.StringVar(value=str(self.plugin.config.get("color_tolerance", 30)))
        ttk.Entry(tolerance_frame, textvariable=self.plugin.tolerance_var, width=5).pack(side=tk.LEFT, padx=(5, 0))
        ttk.Label(tolerance_frame, text="(0-100, lower = more precise)").pack(side=tk.LEFT, padx=(5, 0))

        # Available color profiles
        profiles_frame = ttk.LabelFrame(main_frame, text="Available Color Profiles")
        profiles_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 15))

        # Create listbox for color profiles
        self.plugin.profiles_listbox = tk.Listbox(profiles_frame, height=6)
        self.plugin.profiles_listbox.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        # Refresh profiles list
        self._refresh_color_profiles_list()

        # Profile controls
        profile_controls = ttk.Frame(profiles_frame)
        profile_controls.pack(fill=tk.X, padx=5, pady=5)

        ttk.Button(profile_controls, text="Delete Selected Profile", 
                command=self.plugin._delete_color_profile).pack(side=tk.LEFT)
    
        # Apply button
        ttk.Button(main_frame, text="Apply Color Settings", 
                command=self.plugin._apply_color_settings, 
                style='Success.TButton').pack(anchor=tk.W, pady=(10, 0))
        return main_frame

    def _refresh_color_profiles_list(self):
        """Refresh the color profiles listbox"""
        if hasattr(self.plugin, 'profiles_listbox'):
            self.plugin.profiles_listbox.delete(0, tk.END)
            for profile_name in self.plugin.config["color_filters"].keys():
                colors_count = len(self.plugin.config["color_filters"][profile_name]["target_colors"])
                display_text = f"{profile_name} ({colors_count} colors)"
                self.plugin.profiles_listbox.insert(tk.END, display_text)

    def create_capture_tab(self, parent):
        """Create the capture methods tab with better organization"""
        tab = ttk.Frame(parent)

        # Main container with scrollbar
        canvas = tk.Canvas(tab, highlightthickness=0)
        scrollbar = ttk.Scrollbar(tab, orient=tk.VERTICAL, command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)

        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )

        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)

        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        # Default Capture Method
        default_frame = ttk.LabelFrame(scrollable_frame, text="Default Capture Method", padding=15)
        default_frame.pack(fill=tk.X, pady=(0, 10), padx=5)

        ttk.Label(default_frame, 
                text="Select the default capture method for new regions:",
                wraplength=400).pack(anchor=tk.W, pady=(0, 10))

        self.plugin.capture_method_var = tk.StringVar(
            value=self.plugin.config.get("capture_method", "auto")
        )

        method_combo = ttk.Combobox(default_frame, textvariable=self.plugin.capture_method_var,
                                values=[method.value for method in self.plugin.capture_methods],
                                state="readonly", width=20)
        method_combo.pack(anchor=tk.W, pady=(0, 10))

        # Method descriptions
        desc_frame = ttk.Frame(default_frame)
        desc_frame.pack(fill=tk.X, pady=(0, 10))

        method_descriptions = {
            "auto": "Automatically select the best method based on window type",
            "bitblt": "Fast traditional method, may show black screens for some applications",
            "printwindow": "Works for most problematic windows and applications",
            "printwindow_full": "Best for modern apps and games, captures full content",
            "mss": "Alternative screen capture method, good for full-screen applications"
        }

        self.plugin.method_desc_var = tk.StringVar(value="Select a method to see description")
        desc_label = ttk.Label(desc_frame, textvariable=self.plugin.method_desc_var, 
                            wraplength=400, justify=tk.LEFT, foreground="gray")
        desc_label.pack(anchor=tk.W)

        def update_method_desc(*args):
            method = self.plugin.capture_method_var.get()
            self.plugin.method_desc_var.set(method_descriptions.get(method, ""))

        self.plugin.capture_method_var.trace('w', update_method_desc)
        update_method_desc()  # Initial update

        ttk.Button(default_frame, text="Apply Default Method",
                command=self.plugin._apply_capture_settings).pack(anchor=tk.W)

        # Region-specific Methods
        regions_frame = ttk.LabelFrame(scrollable_frame, text="Region-Specific Methods", padding=15)
        regions_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10), padx=5)

        ttk.Label(regions_frame, 
                text="Configure capture methods for individual regions:",
                wraplength=400).pack(anchor=tk.W, pady=(0, 10))

        # Create treeview for region methods
        columns = ('name', 'bounds', 'current_method')
        self.plugin.region_methods_tree = ttk.Treeview(regions_frame, columns=columns, 
                                                    show='headings', height=8)

        self.plugin.region_methods_tree.heading('name', text='Region Name')
        self.plugin.region_methods_tree.heading('bounds', text='Bounds')
        self.plugin.region_methods_tree.heading('current_method', text='Current Method')

        self.plugin.region_methods_tree.column('name', width=150)
        self.plugin.region_methods_tree.column('bounds', width=120)
        self.plugin.region_methods_tree.column('current_method', width=120)

        # Scrollbar for treeview
        tree_scrollbar = ttk.Scrollbar(regions_frame, orient=tk.VERTICAL, 
                                    command=self.plugin.region_methods_tree.yview)
        self.plugin.region_methods_tree.configure(yscrollcommand=tree_scrollbar.set)

        self.plugin.region_methods_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        tree_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        # Method selection for regions
        method_control_frame = ttk.Frame(regions_frame)
        method_control_frame.pack(fill=tk.X, pady=(10, 0))

        ttk.Label(method_control_frame, text="Set Method:").pack(side=tk.LEFT, padx=(0, 5))

        self.plugin.region_method_var = tk.StringVar(value="auto")
        region_method_combo = ttk.Combobox(method_control_frame, 
                                        textvariable=self.plugin.region_method_var,
                                        values=[method.value for method in  self.plugin.capture_methods],
                                        state="readonly", width=15)
        region_method_combo.pack(side=tk.LEFT, padx=(0, 10))

        ttk.Button(method_control_frame, text="Apply to Selected",
                command=self.plugin._apply_region_method).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(method_control_frame, text="Reset to Default",
                command=self.plugin._reset_region_method).pack(side=tk.LEFT)

        # Refresh button
        refresh_frame = ttk.Frame(regions_frame)
        refresh_frame.pack(fill=tk.X, pady=(5, 0))

        ttk.Button(refresh_frame, text="ðŸ”„ Refresh List",
                command=self.plugin._refresh_region_methods_tree).pack(anchor=tk.W)
    
        # Initial population
        self.plugin._refresh_region_methods_tree()

        return tab
    
    def create_regions_tab(self, parent):
        """Create regions management tab with improved layout"""
        main_frame = ttk.Frame(parent)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Button frame - fixed sizing
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=(0, 15))

        ttk.Button(button_frame, text="ðŸŽ¯ Select Region", 
                command=self.plugin._select_region_visual, 
                width=20).pack(side=tk.LEFT, padx=(0, 10))
    
        ttk.Button(button_frame, text="ðŸªŸ Select Window (List)", 
            command=self.plugin._select_window_from_list,
            width=20).pack(side=tk.LEFT, padx=(0, 10))

        ttk.Button(button_frame, text="ðŸªŸ Select Window", 
                command=self.plugin._select_window_region,
                width=15).pack(side=tk.LEFT, padx=(0, 10))

        ttk.Button(button_frame, text="âž• Add Manual", 
                command=self.plugin._add_manual_region_dialog,
                width=15).pack(side=tk.LEFT, padx=(0, 10))

        ttk.Button(button_frame, text="ðŸŽ¨ Pick Colors", 
                command=self.plugin._open_color_picker_for_region,
                width=15).pack(side=tk.LEFT)

        # Preview frame - fixed height
        preview_frame = ttk.LabelFrame(main_frame, text="Region Preview")
        preview_frame.pack(fill=tk.X, pady=(0, 15))

        self.plugin.preview_canvas = tk.Canvas(preview_frame, height=125, bg='white')
        self.plugin.preview_canvas.pack(fill=tk.X, padx=10, pady=10)

        # Regions list with proper expansion
        list_frame = ttk.LabelFrame(main_frame, text="Configured Regions")
        list_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 15))

        # Treeview with scrollbar
        tree_frame = ttk.Frame(list_frame)
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        # Configure columns
        columns = ('name', 'bounds', 'patterns', 'enabled', 'monitor', 'tts_info', 'capture_method','type')
        self.plugin.regions_tree = ttk.Treeview(tree_frame, columns=columns, show='headings', height=3)

        # Configure columns
        self.plugin.regions_tree.heading('name', text='Name')
        self.plugin.regions_tree.heading('bounds', text='Bounds')
        self.plugin.regions_tree.heading('patterns', text='Patterns')
        self.plugin.regions_tree.heading('enabled', text='Enabled')
        self.plugin.regions_tree.heading('monitor', text='Monitor')
        self.plugin.regions_tree.heading('tts_info', text='TTS Messages')
        self.plugin.regions_tree.heading('capture_method', text='Capture Method')
        self.plugin.regions_tree.heading('type', text='Type')

        self.plugin.regions_tree.column('name', width=120)
        self.plugin.regions_tree.column('bounds', width=120)
        self.plugin.regions_tree.column('patterns', width=150)
        self.plugin.regions_tree.column('enabled', width=80)
        self.plugin.regions_tree.column('monitor', width=80)
        self.plugin.regions_tree.column('tts_info', width=80)
        self.plugin.regions_tree.column('capture_method', width=100)
        self.plugin.regions_tree.column('type', width=120)

        # Scrollbar for treeview
        tree_scroll = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL, command=self.plugin.regions_tree.yview)
        self.plugin.regions_tree.configure(yscrollcommand=tree_scroll.set)

        self.plugin.regions_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        tree_scroll.pack(side=tk.RIGHT, fill=tk.Y)

        # Control buttons - fixed at bottom
        controls_frame = ttk.Frame(main_frame)
        controls_frame.pack(fill=tk.X, pady=(10, 0))

        ttk.Button(controls_frame, text="Test Region", 
                command=self.plugin._test_region).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(controls_frame, text="Edit", 
                command=self.plugin._edit_region).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(controls_frame, text="Remove", 
                command=self.plugin._remove_region).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(controls_frame, text="Toggle", 
                command=self.plugin._toggle_region).pack(side=tk.LEFT)

        # Initial refresh
        self.plugin._refresh_regions_tree()
        # Update preview after a short delay to ensure UI is rendered
        if hasattr(self.plugin, 'app') and hasattr(self.plugin.app, 'root'):
            self.plugin.app.root.after(100, self.plugin._update_preview)

        return main_frame


# from ocr_modules.ui.settings_tabs import SettingsTabs  # NEW IMPORT  # internal import removed

class OCRMonitorPlugin(ETailPlugin):
    def __init__(self, app):
        super().__init__(app)
        self.name = "Bundled OCR Screen Monitor test"
        self.version = "2.2"  # Updated version with capture methods
        self.description = "Monitor specific screen areas for text using OCR with multi-monitor support, gaming optimizations, color filtering, and advanced capture methods"

        # NEW: Initialize config manager
        self.config_manager = ConfigManager()
        self.config = self.config_manager.config  # Keep for compatibility

        self.profile_var = None
        self.preprocess_var = None
        self.fuzzy_var = None
        self.fuzzy_threshold_var = None
        self.performance_var = None
        self.stats_var = None

        self.color_filter_var = None
        self.color_profile_var = None
        self.tolerance_var = None
        self.profiles_listbox = None

#         from ocr_modules.capture import CaptureMethod  # internal import removed
        self.capture_methods = list(CaptureMethod)

        self.performance_stats = {
            'total_checks': 0,
            'successful_ocr': 0,
            'average_time': 0.0,
            'last_check_time': 0.0,
            'capture_method_stats': {}
        }

        self.monitoring = False
        self.monitor_thread = None
        self.regions = []
        self.region_selector = RegionSelector(app)
        self.window_capture = WindowCapture()  # Add WindowCapture instance

        self.regions_tree = None
        self.region_methods_tree = None
        self.preview_canvas = None        

        # Load regions from config
        self.regions = self.config.get("regions", [])
        self.settings_tabs = SettingsTabs(self)
        
    def setup(self):
        """Setup the OCR monitor with configuration"""
        # Verify Tesseract path
        if not self.verify_tesseract():
            self.app.messages(2, 3, "Tesseract not found. Please configure path in plugin settings.")
            return False
            
        self.monitoring = True
        self.monitor_thread = threading.Thread(target=self._monitor_loop, daemon=True)
        self.monitor_thread.start()
        self.app.messages(2, 9, "OCR Screen Monitor enabled with gaming optimizations and color filtering")
        return True
 
    # REPLACE your existing load/save methods with these:
    def load_configuration(self):
        # Now handled entirely by ConfigManager
        pass
        
    def save_configuration(self):
        # Make sure regions are saved to config before saving
        self.config["regions"] = self.regions
        self.config_manager.save_configuration()
 
    def teardown(self):
        """Stop the OCR monitor and save configuration"""
        self.monitoring = False
        if self.monitor_thread and self.monitor_thread.is_alive():
            self.monitor_thread.join(timeout=2.0)
        
        # Print performance summary if enabled
        if self.config.get("performance_monitoring", True) and self.performance_stats['total_checks'] > 0:
            success_rate = (self.performance_stats['successful_ocr'] / self.performance_stats['total_checks']) * 100
            print(f"OCR Performance Summary: {success_rate:.1f}% success rate over {self.performance_stats['total_checks']} checks")
            
        self.app.messages(2, 9, "OCR Screen Monitor disabled")
        self.save_configuration()
        self.reset_monitoring_state()
        
    def verify_tesseract(self):
        """Verify Tesseract is accessible"""
        tesseract_path = self.config.get("tesseract_path", "")
        if tesseract_path and Path(tesseract_path).exists():
            pytesseract.pytesseract.tesseract_cmd = tesseract_path
            return True
        
        # Try to find Tesseract in common locations
        common_paths = [
            r"C:\Program Files\Tesseract-OCR\tesseract.exe",
            r"C:\Program Files (x86)\Tesseract-OCR\tesseract.exe",
            "/usr/bin/tesseract",
            "/usr/local/bin/tesseract"
        ]
        
        for path in common_paths:
            if Path(path).exists():
                self.config["tesseract_path"] = path
                pytesseract.pytesseract.tesseract_cmd = path
                return True
        
        # Last resort: try system PATH
        try:
            pytesseract.get_tesseract_version()
            return True
        except:
            return False
            
    def add_region(self, name, x, y, width, height, patterns, cooldown=300, color_profile=None, tts_messages=None, capture_method=None):
        """Add a screen region to monitor with optional color profile, TTS messages, and capture method"""
        region = {
            'name': name,
            'bounds': (x, y, width, height),
            'patterns': patterns,
            'cooldown': cooldown or self.config.get("default_cooldown", 300),
            'last_seen': {},
            'enabled': True,
            'color_profile': color_profile or self.config.get("current_color_profile", "default"),
            'tts_messages': tts_messages or {},  # Dictionary: pattern -> custom TTS message
            'capture_method': capture_method or self.config.get("capture_method", "auto")  # Per-region capture method
        }
        self.regions.append(region)
        self.save_configuration()
        
    def remove_region(self, region_name):
        """Remove a region by name"""
        self.regions = [r for r in self.regions if r['name'] != region_name]
        self.save_configuration()
        
    def _monitor_loop(self):
        """Optimized monitoring loop with performance tracking"""      
        while self.monitoring:
            loop_start = time.time()
            checks_this_cycle = 0
            successful_checks = 0
            for region in self.regions:
                if not region.get('enabled', True):
                    continue
                # Skip if we're in cooldown for all patterns in this region
                current_time = time.time()
                all_in_cooldown = all(
                    current_time - region['last_seen'].get(pattern, 0) < region.get('cooldown', 300)
                    for pattern in region['patterns']
                )              
                if not all_in_cooldown:
                    checks_this_cycle += 1
                    try:
                        self._check_region(region)
                        successful_checks += 1
                    except Exception as e:
                        print(f"Error checking region {region['name']}: {e}")
            
            # Update performance stats
            if checks_this_cycle > 0:
                self.performance_stats['total_checks'] += checks_this_cycle
                self.performance_stats['successful_ocr'] += successful_checks
                self.performance_stats['last_check_time'] = time.time() - loop_start
          
            # Adaptive sleep based on processing time
            processing_time = time.time() - loop_start
            sleep_time = max(0.1, self.config.get("check_interval", 2.0) - processing_time)
            time.sleep(sleep_time)
            
    def apply_color_filtering(self, image, color_profile_name="default"):
        """Extract only pixels matching target colors and create high-contrast image for OCR"""
        if not self.config.get("enable_color_filtering", True):
            return image
            
        profile = self.config["color_filters"].get(color_profile_name, 
                                                 self.config["color_filters"]["default"])
        
        # Convert PIL Image to numpy array for processing
        img_array = np.array(image)
        
        # Create a mask that starts as all False
        combined_mask = np.zeros(img_array.shape[:2], dtype=bool)
        tolerance = self.config.get("color_tolerance", 30)
        
        for target_color in profile["target_colors"]:
            # Create mask for this specific color
            r, g, b = target_color["r"], target_color["g"], target_color["b"]
            
            # Calculate distance from target color for each pixel
            color_distance = np.sqrt(
                (img_array[:, :, 0] - r) ** 2 +
                (img_array[:, :, 1] - g) ** 2 +
                (img_array[:, :, 2] - b) ** 2
            )
            
            # Add pixels within tolerance to the combined mask
            color_mask = color_distance <= tolerance
            combined_mask = combined_mask | color_mask
        
        # Create output image (white background by default)
        if profile.get("invert_after_filter", True):
            # Black text on white background (best for OCR)
            output_array = np.ones_like(img_array) * 255  # White background
            output_array[combined_mask] = [0, 0, 0]  # Black text
        else:
            # White text on black background
            output_array = np.zeros_like(img_array)  # Black background  
            output_array[combined_mask] = [255, 255, 255]  # White text
        
        return Image.fromarray(output_array)

    def extract_dominant_text_colors(self, image, num_colors=5):
        """Automatically detect dominant colors in the image that might be text"""
        # Convert to numpy array
        img_array = np.array(image)
        
        # Reshape to 2D array of pixels
        pixels = img_array.reshape(-1, 3)
        
        # Simple color grouping to find dominant colors
        from collections import Counter
        
        # Sample pixels to speed up processing
        if len(pixels) > 10000:
            indices = np.random.choice(len(pixels), 10000, replace=False)
            pixels = pixels[indices]
        
        # Group similar colors (simple approach)
        color_buckets = {}
        bucket_size = 20  # Group colors within this range
        
        for pixel in pixels:
            # Skip very dark and very light pixels (likely background)
            brightness = np.mean(pixel)
            if brightness < 30 or brightness > 220:
                continue
                
            # Quantize color
            bucket = tuple((pixel // bucket_size) * bucket_size)
            if bucket in color_buckets:
                color_buckets[bucket] += 1
            else:
                color_buckets[bucket] = 1
        
        # Get most common colors
        most_common = sorted(color_buckets.items(), key=lambda x: x[1], reverse=True)[:num_colors]
        
        dominant_colors = []
        for bucket, count in most_common:
            if count > len(pixels) * 0.01:  # At least 1% of pixels
                color = {
                    "r": int(bucket[0] + bucket_size / 2),
                    "g": int(bucket[1] + bucket_size / 2), 
                    "b": int(bucket[2] + bucket_size / 2)
                }
                dominant_colors.append(color)
        
        return dominant_colors

    def interactive_color_picker(self, region):
        """Interactive tool to pick text colors from a region"""
        try:
            x, y, w, h = region['bounds']
            
            # Capture the region
            with mss.mss() as sct:
                monitor = {"left": x, "top": y, "width": w, "height": h}
                screenshot = sct.grab(monitor)
                image = Image.frombytes('RGB', screenshot.size, screenshot.bgra, 'raw', 'BGRX')
            
            # Create color picker window
            picker_window = tk.Toplevel(self.app.root)
            picker_window.title("Color Picker - Click on Text Colors")
            picker_window.geometry(f"{w+100}x{h+200}")
            picker_window.transient(self.app.root)
            
            # Display image
            photo = ImageTk.PhotoImage(image)
            image_label = ttk.Label(picker_window, image=photo)
            image_label.image = photo
            image_label.pack(padx=10, pady=10)
            
            # Selected colors display
            colors_frame = ttk.Frame(picker_window)
            colors_frame.pack(fill=tk.X, padx=10, pady=5)
            
            ttk.Label(colors_frame, text="Selected Colors:").pack(anchor=tk.W)
            selected_colors = []
            
            colors_display = ttk.Frame(colors_frame)
            colors_display.pack(fill=tk.X, pady=5)
            
            # Auto-detect button
            def auto_detect_colors():
                nonlocal selected_colors
                dominant_colors = self.extract_dominant_text_colors(image)
                selected_colors = dominant_colors
                update_colors_display()
                
            ttk.Button(colors_frame, text="Auto-Detect Colors", 
                      command=auto_detect_colors).pack(anchor=tk.W, pady=5)
            
            def update_colors_display():
                # Clear current display
                for widget in colors_display.winfo_children():
                    widget.destroy()
                
                # Show selected colors
                for i, color in enumerate(selected_colors):
                    color_frame = ttk.Frame(colors_display)
                    color_frame.pack(fill=tk.X, pady=2)
                    
                    # Color swatch
                    color_swatch = tk.Canvas(color_frame, width=20, height=20)
                    color_swatch.create_rectangle(0, 0, 20, 20, 
                                                fill=f'#{color["r"]:02x}{color["g"]:02x}{color["b"]:02x}')
                    color_swatch.pack(side=tk.LEFT, padx=(0, 10))
                    
                    # Color values
                    color_text = f'RGB({color["r"]}, {color["g"]}, {color["b"]})'
                    ttk.Label(color_frame, text=color_text).pack(side=tk.LEFT)
                    
                    # Remove button
                    ttk.Button(color_frame, text="Remove", 
                              command=lambda idx=i: remove_color(idx)).pack(side=tk.RIGHT)
            
            def remove_color(index):
                nonlocal selected_colors
                if 0 <= index < len(selected_colors):
                    selected_colors.pop(index)
                    update_colors_display()
            
            def on_image_click(event):
                nonlocal selected_colors
                # Get clicked color
                if event.x < 0 or event.y < 0 or event.x >= w or event.y >= h:
                    return
                    
                # Get pixel color (account for image scaling in display)
                scale_x = image.width / photo.width()
                scale_y = image.height / photo.height()
                
                pixel_x = int(event.x * scale_x)
                pixel_y = int(event.y * scale_y)
                
                if pixel_x < image.width and pixel_y < image.height:
                    pixel_color = image.getpixel((pixel_x, pixel_y))
                    color = {"r": pixel_color[0], "g": pixel_color[1], "b": pixel_color[2]}
                    
                    # Add to selected colors if not already there
                    if not any(c["r"] == color["r"] and c["g"] == color["g"] and c["b"] == color["b"] 
                              for c in selected_colors):
                        selected_colors.append(color)
                        update_colors_display()
            
            def save_colors():
                if selected_colors:
                    profile_name = f"custom_{region['name']}"
                    self.config["color_filters"][profile_name] = {
                        "target_colors": selected_colors,
                        "invert_after_filter": True
                    }
                    self.config["current_color_profile"] = profile_name
                    self.app.messages(2, 9, f"Color profile '{profile_name}' saved with {len(selected_colors)} colors")
                    picker_window.destroy()
                else:
                    messagebox.showwarning("No Colors", "Please select at least one text color")
            
            def preview_filter():
                if selected_colors:
                    # Create temporary profile for preview
                    temp_profile = {
                        "target_colors": selected_colors,
                        "invert_after_filter": True
                    }
                    
                    # Apply filtering
                    filtered_image = self.apply_color_filtering_with_profile(image, temp_profile)
                    
                    # Show preview
                    preview_photo = ImageTk.PhotoImage(filtered_image)
                    image_label.configure(image=preview_photo)
                    image_label.image = preview_photo
            
            # Bind click event
            image_label.bind("<Button-1>", on_image_click)
            
            # Control buttons
            button_frame = ttk.Frame(picker_window)
            button_frame.pack(fill=tk.X, padx=10, pady=10)
            
            ttk.Button(button_frame, text="Preview Filter", 
                      command=preview_filter).pack(side=tk.LEFT, padx=(0, 10))
            ttk.Button(button_frame, text="Save Colors", 
                      command=save_colors, style='Success.TButton').pack(side=tk.LEFT)
            ttk.Button(button_frame, text="Cancel", 
                      command=picker_window.destroy).pack(side=tk.RIGHT)
            
        except Exception as e:
            messagebox.showerror("Color Picker Error", f"Failed to open color picker: {e}")

    def apply_color_filtering_with_profile(self, image, profile):
        """Apply color filtering with a specific profile"""
        # Convert PIL Image to numpy array
        img_array = np.array(image)
        
        # Create mask
        combined_mask = np.zeros(img_array.shape[:2], dtype=bool)
        tolerance = self.config.get("color_tolerance", 30)
        
        for target_color in profile["target_colors"]:
            r, g, b = target_color["r"], target_color["g"], target_color["b"]
            
            color_distance = np.sqrt(
                (img_array[:, :, 0] - r) ** 2 +
                (img_array[:, :, 1] - g) ** 2 +
                (img_array[:, :, 2] - b) ** 2
            )
            
            color_mask = color_distance <= tolerance
            combined_mask = combined_mask | color_mask
        
        # Create output image
        if profile.get("invert_after_filter", True):
            output_array = np.ones_like(img_array) * 255
            output_array[combined_mask] = [0, 0, 0]
        else:
            output_array = np.zeros_like(img_array)
            output_array[combined_mask] = [255, 255, 255]
        
        return Image.fromarray(output_array)

    def preprocess_image_for_gaming(self, image, region_name=None):
        """Enhanced pre-processing with color filtering"""
        if not self.config.get("enable_preprocessing", True):
            return image
        
        try:
            # Step 1: Apply color filtering if enabled
            if self.config.get("enable_color_filtering", True) and region_name:
                # Find region to get its color profile
                region = next((r for r in self.regions if r['name'] == region_name), None)
                if region and region.get('color_profile'):
                    profile_name = region['color_profile']
                else:
                    profile_name = self.config.get("current_color_profile", "default")
                
                profile = self.config["color_filters"].get(profile_name)
                if profile:
                    image = self.apply_color_filtering_with_profile(image, profile)
            
            # Step 2: Convert to grayscale if not already
            if image.mode != 'L':
                image = image.convert('L')
            
            # Step 3: Get current profile settings for other processing
            profile_name = self.config.get("current_profile", "default")
            profile_settings = self.config["game_profiles"].get(profile_name, {})
            
            # Step 4: Apply scaling
            scale_factor = profile_settings.get("scale_factor", 1.0)
            if scale_factor != 1.0:
                new_width = int(image.width * scale_factor)
                new_height = int(image.height * scale_factor)
                image = image.resize((new_width, new_height), Image.LANCZOS)
            
            # Step 5: Enhance contrast
            contrast_level = profile_settings.get("contrast", 1.5)
            enhancer = ImageEnhance.Contrast(image)
            image = enhancer.enhance(contrast_level)
            
            # Step 6: Enhance sharpness
            sharpness_enhancer = ImageEnhance.Sharpness(image)
            image = sharpness_enhancer.enhance(1.2)
            
            return image
            
        except Exception as e:
            print(f"Enhanced pre-processing error: {e}")
            return image
            
    def _check_region(self, region):
        """Enhanced region checking with sub-region support"""
        current_cooldown = region.get('cooldown', 300)
        try:
            # Set capture method
            capture_method = region.get('capture_method', self.config.get("capture_method", "auto"))
            self.window_capture.set_method(capture_method)

            pil_image = None

            # Handle window regions
            if region.get('type') == 'window':
                # Find the window dynamically
                hwnd = self.find_best_window_match(region)

                if hwnd:
                    # Update window bounds in region (for display purposes)
                    try:
                        left, top, right, bottom = win32gui.GetWindowRect(hwnd)
                        width = right - left
                        height = bottom - top
                        region['bounds'] = (left, top, width, height)
                        region['current_hwnd'] = hwnd  # Temporary, for this session only
                    except:
                        pass

                    # Capture the window (with sub-region support)
                    if region.get('subregion_bounds'):
                        # Capture sub-region of the window
                        sub_x, sub_y, sub_w, sub_h = region['subregion_bounds']
                        print(f"DEBUG: Capturing subregion: {sub_x}, {sub_y}, {sub_w}, {sub_h} from window bounds: {left}, {top}, {width}, {height}")
                    
                        # Create region dict for the sub-region (absolute screen coordinates)
                        region_dict = {
                            "left": left + sub_x,
                            "top": top + sub_y, 
                            "width": sub_w,
                            "height": sub_h
                        }
                        print(f"DEBUG: Absolute subregion coordinates: {region_dict}")
                        subregion_bounds=region['subregion_bounds']
                        pil_image = self.window_capture.capture_region(hwnd=hwnd, subregion_bounds=subregion_bounds)
                        if pil_image:
                            print(f"DEBUG: Subregion capture successful: {pil_image.width}x{pil_image.height}")
                        else:
                            print("DEBUG: Subregion capture failed")
                    else:
                        # Capture entire window
                        print("DEBUG: Capturing entire window (no subregion)")
                        pil_image = self.window_capture.capture_region(hwnd=hwnd)

                    if not pil_image:
                        print(f"Window capture failed for {region['name']}. Window might be minimized or inaccessible.")
                else:
                    print(f"Window not found for region: {region['name']}")
                    return
            else:
                # Screen region capture (existing code)
                x, y, width, height = region['bounds']
                region_dict = {
                    "left": x,
                    "top": y,
                    "width": width,
                    "height": height
                }
                pil_image = self.window_capture.capture_region(region=region_dict)

            if pil_image is None:
                return

            # Enhanced image pre-processing for games with color filtering
            processed_image = self.preprocess_image_for_gaming(pil_image, region['name'])

            # OCR with game-optimized configuration
            ocr_config = self._get_ocr_config()
            text = pytesseract.image_to_string(processed_image, config=ocr_config)

            # Enhanced pattern matching
            if text.strip():
                self._enhanced_pattern_matching(region, text)

        except Exception as e:
            print(f"OCR Error in {region['name']}: {e}")

    def _test_region(self):
        """Test the selected region with proper window region support"""
        print("DEBUG: _test_region method called 587")
        selection = self.regions_tree.selection()
        if selection:
            region_name = self.regions_tree.item(selection[0], 'tags')[0]
            region = next((r for r in self.regions if r['name'] == region_name), None)

            if region:
                print(f"DEBUG: Testing region: {region['name']}, type: {region.get('type', 'screen')}594")
            
                # Create enhanced test dialog that works for both screen and window regions
                self._create_enhanced_region_test_dialog(region)

    def _create_region_test_dialog(self, region):
        """Create an enhanced test dialog with real-time preview"""
        try:
            preview = tk.Toplevel(self.app.root)
            preview.title(f"OCR Test - {region['name']}")
            preview.geometry("900x700")
            preview.transient(self.app.root)
            preview.minsize(800, 600)

            # Center the window
            preview.update_idletasks()
            screen_width = preview.winfo_screenwidth()
            screen_height = preview.winfo_screenheight()
            x_pos = (screen_width // 2) - (900 // 2)
            y_pos = (screen_height // 2) - (700 // 2)
            preview.geometry(f"900x700+{x_pos}+{y_pos}")

            main_container = ttk.Frame(preview)
            main_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

            # Control Panel
            control_frame = ttk.LabelFrame(main_container, text="Capture Controls", padding=10)
            control_frame.pack(fill=tk.X, pady=(0, 10))

            # Method selection with live preview option
            method_row = ttk.Frame(control_frame)
            method_row.pack(fill=tk.X, pady=(0, 10))

            ttk.Label(method_row, text="Capture Method:").pack(side=tk.LEFT)

            self.test_method_var = tk.StringVar(
                value=region.get('capture_method', self.config.get("capture_method", "auto"))
            )
            method_combo = ttk.Combobox(method_row, textvariable=self.test_method_var,
                                    values=[method.value for method in CaptureMethod],
                                    state="readonly", width=20)
            method_combo.pack(side=tk.LEFT, padx=(10, 20))

            # Live preview checkbox
            self.live_preview_var = tk.BooleanVar(value=False)
            live_preview_cb = ttk.Checkbutton(method_row, text="Live Preview",
                                            variable=self.live_preview_var)
            live_preview_cb.pack(side=tk.LEFT, padx=(0, 10))

            # Test button
            test_btn = ttk.Button(method_row, text="Capture & Test", 
                                command=lambda: self._perform_capture_test(region, preview))
            test_btn.pack(side=tk.LEFT)

            # Status indicator
            self.test_status_var = tk.StringVar(value="Ready to test")
            status_label = ttk.Label(control_frame, textvariable=self.test_status_var,
                                foreground="gray", font=("Arial", 9))
            status_label.pack(anchor=tk.W)

            # Results notebook
            results_notebook = ttk.Notebook(main_container)
            results_notebook.pack(fill=tk.BOTH, expand=True, pady=(0, 10))

            # Create tabs
            self.test_tabs = {
                'original': ttk.Frame(results_notebook),
                'processed': ttk.Frame(results_notebook),
                'ocr': ttk.Frame(results_notebook)
            }

            for tab_name, tab_frame in self.test_tabs.items():
                results_notebook.add(tab_frame, text=tab_name.title())

            # Action buttons
            button_frame = ttk.Frame(main_container)
            button_frame.pack(fill=tk.X)

            ttk.Button(button_frame, text="Apply Method to Region", 
                    command=lambda: self._apply_test_method(region),
                    style='Success.TButton').pack(side=tk.LEFT, padx=(0, 10))

            ttk.Button(button_frame, text="Close", 
                    command=preview.destroy).pack(side=tk.RIGHT)

            # Start live preview if enabled
            def toggle_live_preview():
                if self.live_preview_var.get():
                    self._start_live_preview(region, preview)
                else:
                    self._stop_live_preview()

            self.live_preview_var.trace('w', lambda *args: toggle_live_preview())

        except Exception as e:
            messagebox.showerror("Test Failed", f"Error creating test dialog: {e}")

    def _create_enhanced_region_test_dialog(self, region):
        """Create an enhanced test dialog that properly handles window regions"""
        print(f"DEBUG: Testing region: {region['name']}, type: {region.get('type')} 693")
        try:
            preview = tk.Toplevel(self.app.root)
            preview.title(f"OCR Test - {region['name']}")
            preview.geometry("900x700")
            preview.transient(self.app.root)
            preview.minsize(800, 600)

            # Center the window
            preview.update_idletasks()
            screen_width = preview.winfo_screenwidth()
            screen_height = preview.winfo_screenheight()
            x_pos = (screen_width // 2) - (900 // 2)
            y_pos = (screen_height // 2) - (700 // 2)
            preview.geometry(f"900x700+{x_pos}+{y_pos}")

            main_container = ttk.Frame(preview)
            main_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

            # Control Panel
            control_frame = ttk.LabelFrame(main_container, text="Capture Controls", padding=10)
            control_frame.pack(fill=tk.X, pady=(0, 10))

            # Method selection
            method_row = ttk.Frame(control_frame)
            method_row.pack(fill=tk.X, pady=(0, 10))

            ttk.Label(method_row, text="Capture Method:").pack(side=tk.LEFT)

            self.test_method_var = tk.StringVar(
                value=region.get('capture_method', self.config.get("capture_method", "auto"))
            )
            method_combo = ttk.Combobox(method_row, textvariable=self.test_method_var,
                                    values=[method.value for method in CaptureMethod],
                                    state="readonly", width=20)
            method_combo.pack(side=tk.LEFT, padx=(10, 20))

            # Test button
            test_btn = ttk.Button(method_row, text="Capture & Test", 
                                command=lambda: self._perform_enhanced_capture_test(region, preview))
            test_btn.pack(side=tk.LEFT)

            # Status indicator
            self.test_status_var = tk.StringVar(value="Ready to test")
            status_label = ttk.Label(control_frame, textvariable=self.test_status_var,
                                foreground="gray", font=("Arial", 9))
            status_label.pack(anchor=tk.W)

            # Region info
            info_text = f"Region: {region['name']} | Type: {region.get('type', 'screen')}"
            if region.get('type') == 'window':
                info_text += f" | Window: {region.get('window_title', 'Unknown')}"
            ttk.Label(control_frame, text=info_text, font=("Arial", 9, "bold")).pack(anchor=tk.W, pady=(5, 0))

            # Results notebook
            results_notebook = ttk.Notebook(main_container)
            results_notebook.pack(fill=tk.BOTH, expand=True, pady=(0, 10))

            # Create tabs
            self.test_tabs = {
                'original': ttk.Frame(results_notebook),
                'processed': ttk.Frame(results_notebook),
                'ocr': ttk.Frame(results_notebook)
            }

            for tab_name, tab_frame in self.test_tabs.items():
                results_notebook.add(tab_frame, text=tab_name.title())

            # Action buttons
            button_frame = ttk.Frame(main_container)
            button_frame.pack(fill=tk.X)

            ttk.Button(button_frame, text="Apply Method to Region", 
                    command=lambda: self._apply_test_method(region),
                    style='Success.TButton').pack(side=tk.LEFT, padx=(0, 10))

            ttk.Button(button_frame, text="Close", 
                    command=preview.destroy).pack(side=tk.RIGHT)
            print(f"DEBUG: Testing region: {region['name']}, type: {region.get('type')} 770")
            # Auto-test on dialog open for window regions
            if region.get('type') == 'window':
                print(f"DEBUG: Testing region: {region['name']}, type: {region.get('type')} 773")
                preview.after(500, lambda: self._perform_enhanced_capture_test(region, preview))

        except Exception as e:
            messagebox.showerror("Test Failed", f"Error creating test dialog: {e}")

    def _perform_enhanced_capture_test(self, region, parent):
        """Perform capture test that properly handles both screen and window regions with subregions"""
        try:
            self.test_status_var.set("Capturing...")
            parent.update()
    
            # Set capture method
            self.window_capture.set_method(self.test_method_var.get())

            image = None
            capture_success = False

            # Handle window regions
            if region.get('type') == 'window':
                print(f"DEBUG: Capturing window region: {region.get('window_title', 'Unknown')}")
                print(f"DEBUG: Subregion bounds: {region.get('subregion_bounds', 'None')}")
        
                # Try to find the window if hwnd is not available or invalid
                hwnd = region.get('hwnd')
                if not hwnd or not self._is_window_valid(hwnd):
                    print("DEBUG: Finding window dynamically...")
                    hwnd = self.find_best_window_match(region)
                    if hwnd:
                        region['hwnd'] = hwnd
                        print(f"DEBUG: Found window: {hwnd}")
                    else:
                        self.test_status_var.set("âŒ Window not found")
                        messagebox.showerror("Window Not Found", 
                                        f"Could not find window for region '{region['name']}'. "
                                        f"The window might be closed or minimized.")
                        return
        
                # Capture the window - WITH SUBREGION SUPPORT USING WINDOW CAPTURE
                if region.get('subregion_bounds'):
                    # Use the new method that captures subregion using window capture
                    subregion_bounds = region['subregion_bounds']
                    print(f"DEBUG: Capturing window subregion: hwnd={hwnd}, subregion={subregion_bounds}")
                    image = self.window_capture.capture_region(
                        hwnd=hwnd, 
                        subregion_bounds=subregion_bounds
                    )

                    if image:
                        capture_success = True
                        print(f"DEBUG: Window subregion capture successful: {image.width}x{image.height}")
                    else:
                        print("DEBUG: Window subregion capture failed")
                        # Fallback to screen capture for subregion
                        print("DEBUG: Falling back to screen capture for subregion")
                        window_x, window_y, window_w, window_h = region['bounds']
                        sub_x, sub_y, sub_w, sub_h = subregion_bounds
                        region_dict = {
                            "left": window_x + sub_x,
                            "top": window_y + sub_y, 
                            "width": sub_w,
                            "height": sub_h
                        }
                        image = self.window_capture.capture_region(region=region_dict)
                        if image:
                            capture_success = True
                            print(f"DEBUG: Screen subregion capture successful: {image.width}x{image.height}")
                else:
                    # Capture entire window
                    print("DEBUG: Capturing entire window (no subregion)")
                    image = self.window_capture.capture_region(hwnd=hwnd)
                    if image:
                        capture_success = True
                        print(f"DEBUG: Full window capture successful: {image.width}x{image.height}")

                if not capture_success:
                    self.test_status_var.set("âŒ Window capture failed")
                    messagebox.showerror("Capture Failed", 
                                    "Could not capture window. The window might be minimized, "
                                    "covered, or inaccessible. Try a different capture method.")
                    return
                
            else:
                # Screen region capture (existing code)
                x, y, w, h = region['bounds']
                region_dict = {"left": x, "top": y, "width": w, "height": h}
                print(f"DEBUG: Capturing screen region: {region_dict}")

                image = self.window_capture.capture_region(region=region_dict)

                if image:
                    capture_success = True
                    print(f"DEBUG: Screen capture successful: {image.width}x{image.height}")
                else:
                    self.test_status_var.set("âŒ Screen capture failed")
                    messagebox.showerror("Capture Failed", "Could not capture screen region.")
                    return
    
            if capture_success and image:
                # Process image
                processed_image = self.preprocess_image_for_gaming(image, region['name'])
        
                # Perform OCR
                ocr_config = self._get_ocr_config()
                processed_text = pytesseract.image_to_string(processed_image, config=ocr_config)
        
                # Display results with region information including subregion
                self._display_enhanced_test_results(image, processed_image, "", processed_text, region)
                self.test_status_var.set("âœ… Test completed successfully")
        
        except Exception as e:
            self.test_status_var.set("âŒ Test failed")
            error_msg = f"Error during test: {str(e)}"
            print(f"DEBUG: {error_msg}")
            import traceback
            traceback.print_exc()
            messagebox.showerror("Test Error", error_msg)

    def _is_window_valid(self, hwnd):
        """Check if a window handle is valid and the window is visible"""
        try:
            import win32gui
            if not hwnd or not win32gui.IsWindow(hwnd):
                print(f"DEBUG: not hwnd or not win32gui.IsWindow(hwnd){hwnd}")
                return False
        
            # Check if window is visible and not minimized
            if not win32gui.IsWindowVisible(hwnd):
                print(f"DEBUG: not win32gui.IsWindowVisible(hwnd){hwnd}")
                return False
            
            # Check if window is iconic (minimized)
            if win32gui.IsIconic(hwnd):
                print(f"DEBUG: win32gui.IsIconic(hwnd){hwnd}")
                return False
            
            return True
        
        except Exception as e:
            print(f"DEBUG: Window validation failed: {e}")
            return False

    def _display_enhanced_test_results(self, original_img, processed_img, original_text, processed_text, region):
        """Display test results with region information"""
        # Display original image
        self._display_image_tab(self.test_tabs['original'], original_img, 
                            f"Original Image - {region['name']}")
    
        # Display processed image  
        self._display_image_tab(self.test_tabs['processed'], processed_img, 
                            f"Processed Image - {region['name']}")
    
        # Display OCR results with region context
        self._display_enhanced_ocr_tab(self.test_tabs['ocr'], original_text, processed_text, region)

    def _display_enhanced_ocr_tab(self, tab, original_text, processed_text, region):
        """Display OCR results with region context including subregion info"""
        # Clear existing content
        for widget in tab.winfo_children():
            widget.destroy()
    
        # Create notebook for OCR results
        ocr_notebook = ttk.Notebook(tab)
        ocr_notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Region info frame
        info_frame = ttk.Frame(ocr_notebook)
        ocr_notebook.add(info_frame, text="Region Info")

        # Display region information with subregion details
        info_text = f"Region: {region['name']}\n"
        info_text += f"Type: {region.get('type', 'screen')}\n"
    
        if region.get('type') == 'window':
            info_text += f"Window: {region.get('window_title', 'Unknown')}\n"
            info_text += f"Process: {region.get('process_name', 'Unknown')}\n"
            info_text += f"Capture Method: {region.get('capture_method', 'auto')}\n"
        
            # ADD SUBREGION INFO
            if region.get('subregion_bounds'):
                sub_x, sub_y, sub_w, sub_h = region['subregion_bounds']
                info_text += f"Subregion: {sub_w}x{sub_h} at ({sub_x},{sub_y})\n"
            else:
                info_text += "Subregion: Entire window\n"
            
            info_text += f"Window Bounds: {region['bounds']}\n"
        else:
            info_text += f"Bounds: {region['bounds']}\n"
    
        info_text += f"Patterns: {', '.join(region['patterns'])}\n"
        info_text += f"Cooldown: {region.get('cooldown', 300)}s\n"
        info_text += f"Color Profile: {region.get('color_profile', 'default')}"
    
        info_text_widget = tk.Text(info_frame, wrap=tk.WORD, width=80, height=8)
        info_scrollbar = ttk.Scrollbar(info_frame, orient=tk.VERTICAL, command=info_text_widget.yview)
        info_text_widget.configure(yscrollcommand=info_scrollbar.set)
    
        info_text_widget.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        info_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
    
        info_text_widget.insert(1.0, info_text)
        info_text_widget.config(state=tk.DISABLED)
    
        # Original OCR tab
        orig_ocr_tab = ttk.Frame(ocr_notebook)
        ocr_notebook.add(orig_ocr_tab, text="Original OCR")
    
        orig_text_widget = tk.Text(orig_ocr_tab, wrap=tk.WORD, width=80, height=15)
        orig_scrollbar = ttk.Scrollbar(orig_ocr_tab, orient=tk.VERTICAL, command=orig_text_widget.yview)
        orig_text_widget.configure(yscrollcommand=orig_scrollbar.set)
    
        orig_text_widget.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        orig_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
    
        orig_text_widget.insert(1.0, original_text if original_text.strip() else "No text detected")
        orig_text_widget.config(state=tk.DISABLED)
    
        # Processed OCR tab
        proc_ocr_tab = ttk.Frame(ocr_notebook)
        ocr_notebook.add(proc_ocr_tab, text="Processed OCR")
    
        proc_text_widget = tk.Text(proc_ocr_tab, wrap=tk.WORD, width=80, height=15)
        proc_scrollbar = ttk.Scrollbar(proc_ocr_tab, orient=tk.VERTICAL, command=proc_text_widget.yview)
        proc_text_widget.configure(yscrollcommand=proc_scrollbar.set)
    
        proc_text_widget.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        proc_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
    
        proc_text_widget.insert(1.0, processed_text if processed_text.strip() else "No text detected")
        proc_text_widget.config(state=tk.DISABLED)

    def _start_live_preview(self, region, parent):
        """Start live preview of the region"""
        self.live_preview_active = True
        self._update_live_preview(region, parent)

    def _stop_live_preview(self):
        """Stop live preview"""
        self.live_preview_active = False

    def _update_live_preview(self, region, parent):
        """Update live preview"""
        if not self.live_preview_active:
            return
        
        try:
            # Capture with current method
            self.window_capture.set_method(self.test_method_var.get())
            x, y, w, h = region['bounds']
            region_dict = {"left": x, "top": y, "width": w, "height": h}
            image = self.window_capture.capture_region(region=region_dict)
        
            if image:
                # Update original tab
                self._display_image_tab(self.test_tabs['original'], image, "Live Preview - Original")
            
                # Update processed tab
                processed_image = self.preprocess_image_for_gaming(image, region['name'])
                self._display_image_tab(self.test_tabs['processed'], processed_image, "Live Preview - Processed")
            
                self.test_status_var.set("Live preview active")
            else:
                self.test_status_var.set("Live preview failed - cannot capture")
            
        except Exception as e:
            self.test_status_var.set(f"Live preview error: {str(e)}")
    
        # Schedule next update
        if self.live_preview_active:
            parent.after(1000, lambda: self._update_live_preview(region, parent))

    def _perform_capture_test(self):
        """Perform a single capture test that handles both screen and window regions"""
        try:
            self.status_var.set("Capturing...")
            self.dialog.update()
        
            # Set capture method
            self.plugin.window_capture.set_method(self.method_var.get())
        
            # Capture based on region type
            image = None
            if self.region.get('type') == 'window' and self.region.get('hwnd'):
                # Window region capture
                print(f"DEBUG: Capturing window region with hwnd: {self.region['hwnd']}")
                image = self.plugin.window_capture.capture_region(hwnd=self.region['hwnd'])
            
                # If window capture fails, try to find the window again
                if image is None:
                    print("DEBUG: Window capture failed, trying to find window...")
                    hwnd = self.plugin.find_best_window_match(self.region)
                    if hwnd:
                        self.region['hwnd'] = hwnd
                        image = self.plugin.window_capture.capture_region(hwnd=hwnd)
            else:
                # Screen region capture
                x, y, w, h = self.region['bounds']
                region_dict = {"left": x, "top": y, "width": w, "height": h}
                print(f"DEBUG: Capturing screen region: {region_dict}")
                image = self.plugin.window_capture.capture_region(region=region_dict)
        
            if image is None:
                self.status_var.set("âŒ Capture failed")
                messagebox.showerror("Capture Failed", "Could not capture region image.")
                return
        
            # Process image
            processed_image = self.plugin.preprocess_image_for_gaming(image, self.region['name'])
        
            # Perform OCR
            import pytesseract
            ocr_config = self.plugin._get_ocr_config()
            processed_text = pytesseract.image_to_string(processed_image, config=ocr_config)
        
            # Display results
            self._display_test_results(image, processed_image, original_text="", processed_text=processed_text)
            self.status_var.set("âœ… Test completed successfully")
        
        except Exception as e:
            self.status_var.set("âŒ Test failed")
            messagebox.showerror("Test Error", f"Error during test: {str(e)}")
            import traceback
            traceback.print_exc()

    def _display_test_results(self, original_img, processed_img, original_text, processed_text):
        """Display test results in the preview window"""
        # Display original image
        self._display_image_tab(self.test_tabs['original'], original_img, "Original Image")
        
        # Display processed image  
        self._display_image_tab(self.test_tabs['processed'], processed_img, "Processed Image")
        
        # Display OCR results
        self._display_ocr_tab(self.test_tabs['ocr'], original_text, processed_text)

    def _display_image_tab(self, tab, image, title):
        """Display image in a tab with proper horizontal and vertical scrolling"""
        # Clear existing content
        for widget in tab.winfo_children():
            widget.destroy()
    
        # Create main container
        main_container = ttk.Frame(tab)
        main_container.pack(fill=tk.BOTH, expand=True)
    
        # Create a frame for the image and info
        content_frame = ttk.Frame(main_container)
        content_frame.pack(fill=tk.BOTH, expand=True)
    
        # Create canvas with both scrollbars
        canvas = tk.Canvas(content_frame, highlightthickness=0)
    
        # Create scrollbars
        v_scrollbar = ttk.Scrollbar(content_frame, orient=tk.VERTICAL, command=canvas.yview)
        h_scrollbar = ttk.Scrollbar(content_frame, orient=tk.HORIZONTAL, command=canvas.xview)
    
        # Configure canvas
        canvas.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)
    
        # Create frame inside canvas for the image
        image_frame = ttk.Frame(canvas)
    
        def configure_scrollregion(event=None):
            # Update the scrollregion to encompass the inner frame
            bbox = canvas.bbox("all")
            if bbox:
                canvas.configure(scrollregion=bbox)
    
        image_frame.bind("<Configure>", configure_scrollregion)
    
        # Add image frame to canvas
        canvas_window = canvas.create_window((0, 0), window=image_frame, anchor="nw")
    
        # Function to resize canvas window when canvas is resized
        def on_canvas_configure(event):
            # Set the canvas window width to the canvas width
            #canvas.itemconfig(canvas_window, width=event.width) Commented to make the scroll work.
            configure_scrollregion()
    
        canvas.bind("<Configure>", on_canvas_configure)
    
        # Pack canvas and scrollbars with proper grid layout
        canvas.grid(row=0, column=0, sticky="nsew")
        v_scrollbar.grid(row=0, column=1, sticky="ns")
        h_scrollbar.grid(row=1, column=0, sticky="ew")
    
        # Configure grid weights for proper expansion
        content_frame.grid_rowconfigure(0, weight=1)
        content_frame.grid_columnconfigure(0, weight=1)
    
        # Display image
        photo = ImageTk.PhotoImage(image)
        label = ttk.Label(image_frame, image=photo)
        label.image = photo  # Keep a reference
        label.pack(padx=10, pady=10)
    
        # Image info
        info_text = f"{title}: {image.width} x {image.height} pixels"
        ttk.Label(image_frame, text=info_text, font=("Arial", 9, "bold")).pack(pady=(0, 10))
    
        # Instructions for scrolling
        if image.width > 600 or image.height > 400:
            scroll_info = "Use scrollbars to navigate the image"
            ttk.Label(image_frame, text=scroll_info, font=("Arial", 8), foreground="gray").pack(pady=(0, 5))
    
        # Force initial scrollregion configuration
        tab.update_idletasks()
        configure_scrollregion()

    def _display_ocr_tab(self, tab, original_text, processed_text):
        """Display OCR results in tab"""
        # Clear existing content
        for widget in tab.winfo_children():
            widget.destroy()
            
        # Create notebook for OCR results
        ocr_notebook = ttk.Notebook(tab)
        ocr_notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Original OCR tab
        orig_ocr_tab = ttk.Frame(ocr_notebook)
        ocr_notebook.add(orig_ocr_tab, text="Original OCR")
        
        orig_text_widget = tk.Text(orig_ocr_tab, wrap=tk.WORD, width=80, height=15)
        orig_scrollbar = ttk.Scrollbar(orig_ocr_tab, orient=tk.VERTICAL, command=orig_text_widget.yview)
        orig_text_widget.configure(yscrollcommand=orig_scrollbar.set)
        
        orig_text_widget.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        orig_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        orig_text_widget.insert(1.0, original_text if original_text.strip() else "No text detected")
        orig_text_widget.config(state=tk.DISABLED)
        
        # Processed OCR tab
        proc_ocr_tab = ttk.Frame(ocr_notebook)
        ocr_notebook.add(proc_ocr_tab, text="Processed OCR")
        
        proc_text_widget = tk.Text(proc_ocr_tab, wrap=tk.WORD, width=80, height=15)
        proc_scrollbar = ttk.Scrollbar(proc_ocr_tab, orient=tk.VERTICAL, command=proc_text_widget.yview)
        proc_text_widget.configure(yscrollcommand=proc_scrollbar.set)
        
        proc_text_widget.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        proc_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        proc_text_widget.insert(1.0, processed_text if processed_text.strip() else "No text detected")
        proc_text_widget.config(state=tk.DISABLED)

    def _apply_test_method(self, region):
        """Apply the tested capture method to the region"""
        new_method = self.test_method_var.get()
        region['capture_method'] = new_method
        self._refresh_regions_tree()
        messagebox.showinfo("Success", f"Capture method '{new_method}' applied to region '{region['name']}'")

    def _enhanced_pattern_matching(self, region, text):
        """Enhanced pattern matching that groups detections by region"""
        clean_text = text.lower()
        detected_patterns = []
    
        print(f"DEBUG: Checking region '{region['name']}' - Text: {text.strip()}")
        
        for pattern in region['patterns']:
            pattern_lower = pattern.lower()
            print(f"DEBUG: Looking for pattern '{pattern}' in text")

            # Exact match
            if pattern_lower in clean_text:
                detected_patterns.append(pattern)
                print(f"DEBUG: Exact match found for '{pattern}'")
                continue

            # Fuzzy matching for game text variations
            if self.config.get("enable_fuzzy_matching", False):
                if self._check_fuzzy_match(pattern, clean_text):
                    print(f"DEBUG: Fuzzy match found for '{pattern}'")
                    detected_patterns.append(pattern)

        # Send one alert for all patterns detected in this region
        if detected_patterns:
            print(f"DEBUG: Patterns detected: {detected_patterns}")
            self._trigger_region_alert(region, detected_patterns, text)
        else:
            print(f"DEBUG: No patterns detected in region '{region['name']}'")

        return detected_patterns

    def _trigger_region_alert(self, region, patterns, text):
        """Handle region detection with consolidated alert"""
        current_time = time.time()

        # Check cooldown for the region (not individual patterns)
        last_region_alert = region.get('last_region_alert', 0)
        cooldown = region.get('cooldown', 300)

        print(f"DEBUG: Cooldown check - Last: {last_region_alert}, Current: {current_time}, Diff: {current_time - last_region_alert}, Cooldown: {cooldown}")

        if current_time - last_region_alert > cooldown:
            region['last_region_alert'] = current_time

            # Update last_seen for individual patterns (for tracking)
            for pattern in patterns:
                region['last_seen'][pattern] = current_time

            # Create consolidated message
            if len(patterns) == 1:
                message = f"OCR detected '{patterns[0]}' in {region['name']}"
            else:
                patterns_str = ", ".join(patterns)
                message = f"OCR detected {len(patterns)} patterns in {region['name']}: {patterns_str}"

            # Enhanced logging
            log_message = (
                f"Region alert for {region['name']}:\n"
                f"Patterns: {', '.join(patterns)}\n"
                f"Detected text: {text[:100]}{'...' if len(text) > 100 else ''}\n"
                f"Region bounds: {region['bounds']}"
            )
            print(f"OCR Region Alert: {log_message}")

            self._on_region_detected(region['name'], patterns, text, message)

    def _on_region_detected(self, region_name, patterns, detected_text, message):
        """Handle region detection with custom TTS messages"""
        print(f"OCR Alert: {message}")

        # Safe notification handling
        try:
            if hasattr(self.app, 'action_handler'):
                print(f"config not: {self.config.get('not_alerts', False)}")
                print(f"config not: {self.config.get('not_alerts')}")
                if self.config.get("not_alerts", False):
                    print(f"OCR Notification Alert: {message}")
                    self.app.action_handler.show_notification(message)

                # TTS with custom messages
                if self.config.get("tts_alerts", False) and hasattr(self.app.action_handler, 'speak_text'):
                    print(f"OCR TTS Alert: {message}")
                    # Find the region to get TTS messages
                    region = next((r for r in self.regions if r['name'] == region_name), None)

                    if region and patterns:
                        # Use custom TTS message if available, otherwise use pattern
                        tts_messages = []
                        for pattern in patterns:
                            custom_tts = region.get('tts_messages', {}).get(pattern)
                            if custom_tts:
                                tts_messages.append(custom_tts)
                            else:
                                tts_messages.append(pattern)

                        if len(tts_messages) == 1:
                            tts_text = tts_messages[0]
                        else:
                            tts_text = f"{', '.join(tts_messages)} detected {len(tts_messages)} times"

                        self.app.action_handler.speak_text(tts_text, "")

        except Exception as e:
            print(f"Notification failed: {e}")

    def _check_fuzzy_match(self, pattern, clean_text):
        """Check for a single fuzzy match and return True if found"""
        try:
            from fuzzywuzzy import fuzz

            lines = clean_text.split('\n')
            for line in lines:
                line_clean = line.strip()
                if len(line_clean) < 3:
                    continue

                similarity = fuzz.partial_ratio(pattern.lower(), line_clean)
                threshold = self.config.get("fuzzy_threshold", 85)

                if similarity >= threshold:
                    return True  # Pattern found
            return False  # Pattern not found

        except ImportError:
            # fuzzywuzzy not installed, skip fuzzy matching
            if not hasattr(self, '_fuzzy_warning_shown'):
                print("FuzzyWuzzy not installed. Install with: pip install fuzzywuzzy python-Levenshtein")
                self._fuzzy_warning_shown = True
            return False
           
    def _trigger_pattern(self, region, pattern, text, match_type):
        """Handle pattern detection with enhanced logging"""
        current_time = time.time()
        last_seen = region['last_seen'].get(pattern, 0)
        cooldown = region.get('cooldown', 300)
        print(f"Cooldown: {cooldown}")
        if current_time - last_seen > cooldown:
            region['last_seen'][pattern] = current_time
            
            # Enhanced logging with more context
            log_message = (
                f"OCR {match_type} match: '{pattern}' in {region['name']}\n"
                f"Detected text: {text[:100]}{'...' if len(text) > 100 else ''}\n"
                f"Region bounds: {region['bounds']}\n"
                f"Profile: {self.config.get('current_profile', 'default')}\n"
                f"Cooldown: {cooldown}"
            )
            print(f"OCR Alert: {log_message}")
            print(f"Cooldown: {cooldown}")
            self._on_pattern_detected(region['name'], pattern, text)

    def _get_ocr_config(self):
        """Enhanced OCR configuration with game profiles"""
        profile = self.config.get("current_profile", "default")
        profile_settings = self.config["game_profiles"].get(profile, {})
        
        config_str = ""
        
        # Language
        lang = self.config.get("language", "eng")
        if lang and lang != "eng":
            config_str += f"-l {lang} "
            
        # Profile-specific settings
        psm = profile_settings.get("page_segmentation_mode", 
                                  self.config.get("page_segmentation_mode", 6))
        oem = profile_settings.get("ocr_engine_mode", 
                                  self.config.get("ocr_engine_mode", 3))
        config_str += f"--psm {psm} --oem {oem}"
        
        return config_str.strip()
            
    def _on_pattern_detected(self, region_name, pattern, detected_text):
        """Handle detected pattern with safe notification"""
        message = f"OCR detected '{pattern}' in {region_name}"
        print(f"OCR Alert: {message}")
    
        # Safe notification handling
        try:
            # Check if the action_handler exists and has the method
            if hasattr(self.app, 'action_handler'):
                self.app.action_handler.show_notification(message)

                # Optional: Speak alert if TTS is enabled
                if self.config.get("tts_alerts", False):
                    # Check if speak_text method exists before calling it
                    if hasattr(self.app.action_handler, 'speak_text'):
                        self.app.action_handler.speak_text(f"Alert: {pattern} detected", "")
            else:
                print("Notification system not available: action_handler not found")
            
        except Exception as e:
            print(f"DeBUG Notification failed: {e}")
            import traceback
            traceback.print_exc()

    def get_settings_widget(self, parent):
        """Enhanced settings widget with capture methods tab"""
        def create_widget(master):    
            main_frame = ttk.Frame(master)
            main_frame.pack(fill=tk.BOTH, expand=True)

            main_frame.master.minsize(500, 500)

            notebook = ttk.Notebook(main_frame)
            notebook.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

            # Create tabs - ADD CAPTURE METHODS TAB
            tesseract_tab = self.settings_tabs.create_tesseract_tab(notebook)
            regions_tab = self.settings_tabs.create_regions_tab(notebook)
            ocr_tab = self.settings_tabs.create_ocr_tab(notebook) 
            gaming_tab = self.settings_tabs.create_gaming_tab(notebook)
            color_tab = self.settings_tabs.create_colors_tab(notebook)
            capture_tab = self.settings_tabs.create_capture_tab(notebook)

            # Add to notebook
            notebook.add(tesseract_tab, text="Tesseract")
            notebook.add(regions_tab, text="Regions")
            notebook.add(ocr_tab, text="OCR Settings")
            notebook.add(gaming_tab, text="Gaming")
            notebook.add(color_tab, text="Colors")
            notebook.add(capture_tab, text="Capture")

            return main_frame

        return create_widget

    def _create_scrollable_frame(self, parent):
        """Create a properly scrollable frame that works with notebook"""
        # Create frame for the tab
        tab_frame = ttk.Frame(parent)

        # Create canvas and scrollbar
        canvas = tk.Canvas(tab_frame, highlightthickness=0)
        scrollbar = ttk.Scrollbar(tab_frame, orient=tk.VERTICAL, command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)

        # Configure scrolling
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )

        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)

        # Pack elements
        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        # Update scrollregion when frame changes
        def on_frame_configure(event):
            canvas.configure(scrollregion=canvas.bbox("all"))

        scrollable_frame.bind("<Configure>", on_frame_configure)

        return scrollable_frame  # Return the inner frame for content

    def _select_window_region(self):
        """Select a window for capture"""
        self.region_selector.select_window()

    def _refresh_region_methods_tree(self):
        """Refresh the region methods treeview with existence checks"""
        if not hasattr(self, 'region_methods_tree') or self.region_methods_tree is None:
            return

        try:
            # Check if widget still exists
            if not self.region_methods_tree.winfo_exists():
                return

            # Clear existing items
            for item in self.region_methods_tree.get_children():
                self.region_methods_tree.delete(item)

            # Populate with current regions
            for region in self.regions:
                # Handle missing bounds gracefully
                if 'bounds' in region:
                    bounds_str = f"{region['bounds'][0]},{region['bounds'][1]},{region['bounds'][2]},{region['bounds'][3]}"
                else:
                    bounds_str = "No bounds"

                current_method = region.get('capture_method', self.config.get("capture_method", "auto"))

                self.region_methods_tree.insert('', tk.END, values=(
                    region['name'],
                    bounds_str,
                    current_method
                ), tags=(region['name'],))

        except (tk.TclError, KeyError, IndexError) as e:
            # Widget was destroyed or data issue, just ignore
            print(f"Region methods tree refresh failed: {e}")
            return

    def _apply_region_method(self):
        """Apply selected method to chosen region"""
        if not hasattr(self, 'region_methods_tree') or not self.region_methods_tree:
            return

        selection = self.region_methods_tree.selection()
        if selection:
            try:
                region_name = self.region_methods_tree.item(selection[0], 'tags')[0]
                new_method = self.region_method_var.get()

                for region in self.regions:
                    if region['name'] == region_name:
                        region['capture_method'] = new_method
                        break

                self.ensure_save()
                self._refresh_region_methods_tree()
                self._refresh_regions_tree()
                self.app.messages(2, 9, f"Applied '{new_method}' to region '{region_name}'")
            except Exception as e:
                print(f"Error applying region method: {e}")
        else:
            messagebox.showwarning("No Selection", "Please select a region first")

    def _reset_region_method(self):
        """Reset region method to default"""
        if not hasattr(self, 'region_methods_tree') or not self.region_methods_tree:
            return

        selection = self.region_methods_tree.selection()
        if selection:
            try:
                region_name = self.region_methods_tree.item(selection[0], 'tags')[0]

                for region in self.regions:
                    if region['name'] == region_name:
                        if 'capture_method' in region:
                            del region['capture_method']
                        break

                self.ensure_save()
                self._refresh_region_methods_tree()
                self._refresh_regions_tree()
                self.app.messages(2, 9, f"Reset capture method for region '{region_name}'")
            except Exception as e:
                print(f"Error resetting region method: {e}")
        else:
            messagebox.showwarning("No Selection", "Please select a region first")

    def _apply_capture_settings(self):
        """Apply capture settings"""
        try:
            self.config["capture_method"] = self.capture_method_var.get()
            self.ensure_save()
            self.app.messages(2, 9, "Capture settings applied")
        except Exception as e:
            self.app.messages(2, 3, f"Error applying capture settings: {e}")

    def _ensure_ui_visibility(self):
        """Ensure all UI elements are properly visible"""
        # Refresh the preview after UI is drawn
        if hasattr(self, 'preview_canvas'):
            self.app.root.after(500, self._update_preview)
    
        # Ensure treeview columns are properly sized
        if hasattr(self, 'regions_tree'):
            self.app.root.after(500, self._resize_treeview_columns)

    def _resize_treeview_columns(self):
        """Auto-resize treeview columns to fit content"""
        for col in self.regions_tree['columns']:
            self.regions_tree.column(col, width=tk.font.Font().measure(col.title()) + 20)

    def _refresh_color_profiles_list(self):
        """Refresh the color profiles listbox"""
        if hasattr(self, 'profiles_listbox'):
            self.profiles_listbox.delete(0, tk.END)
            for profile_name in self.config["color_filters"].keys():
                colors_count = len(self.config["color_filters"][profile_name]["target_colors"])
                display_text = f"{profile_name} ({colors_count} colors)"
                self.profiles_listbox.insert(tk.END, display_text)
    
    def _delete_color_profile(self):
        """Delete selected color profile"""
        selection = self.profiles_listbox.curselection()
        if selection:
            profile_index = selection[0]
            profile_name = list(self.config["color_filters"].keys())[profile_index]
            
            # Don't allow deleting built-in profiles
            if profile_name in ["default", "dark_text"]:
                messagebox.showwarning("Cannot Delete", "Cannot delete built-in color profiles")
                return
                
            if messagebox.askyesno("Confirm Delete", f"Delete color profile '{profile_name}'?"):
                del self.config["color_filters"][profile_name]
                self._refresh_color_profiles_list()
                
                # Update regions using this profile
                for region in self.regions:
                    if region.get('color_profile') == profile_name:
                        region['color_profile'] = "default"
                
                self._refresh_regions_tree()
                self.save_configuration()
                self.app.messages(2, 9, f"Color profile '{profile_name}' deleted")

    def _apply_color_settings(self):
        """Apply color filtering settings"""
        try:
            self.config["enable_color_filtering"] = self.color_filter_var.get()
            self.config["current_color_profile"] = self.color_profile_var.get()
            self.config["color_tolerance"] = int(self.tolerance_var.get())
            
            self.app.messages(2, 9, "Color filtering settings applied")
            self.save_configuration()
            
        except ValueError as e:
            self.app.messages(2, 3, f"Invalid setting value: {e}")

    def _open_color_picker_for_region(self):
        """Open color picker for the selected region"""
        selection = self.regions_tree.selection()
        if selection:
            region_name = self.regions_tree.item(selection[0], 'tags')[0]
            region = next((r for r in self.regions if r['name'] == region_name), None)
            
            if region:
                self.interactive_color_picker(region)
                # Refresh the regions tree to show updated color profile
                self._refresh_regions_tree()
            else:
                messagebox.showwarning("No Region", "Please select a valid region first")
        else:
            messagebox.showwarning("No Selection", "Please select a region first")

    def _update_performance_stats(self):
        """Update performance statistics display"""
        if self.performance_stats['total_checks'] > 0:
            success_rate = (self.performance_stats['successful_ocr'] / self.performance_stats['total_checks']) * 100
            stats_text = (f"Total Checks: {self.performance_stats['total_checks']}\n"
                        f"Success Rate: {success_rate:.1f}%\n"
                        f"Avg Check Time: {self.performance_stats['last_check_time']:.3f}s")
        else:
            stats_text = "No performance data yet\nRun the monitor to collect stats"
    
        if hasattr(self, 'stats_var') and self.stats_var:
            self.stats_var.set(stats_text)

    def _apply_gaming_settings(self):
        """Apply gaming-specific settings"""
        try:
            self.config["current_profile"] = self.profile_var.get()
            self.config["enable_preprocessing"] = self.preprocess_var.get()
            self.config["enable_fuzzy_matching"] = self.fuzzy_var.get()
            self.config["fuzzy_threshold"] = int(self.fuzzy_threshold_var.get())
            self.config["performance_monitoring"] = self.performance_var.get()
            
            self._update_performance_stats()
            self.app.messages(2, 9, "Gaming settings applied")
            self.save_configuration()

        except ValueError as e:
            self.app.messages(2, 3, f"Invalid setting value: {e}")

    def _select_region_visual(self):
        """Select region using visual mouse selection"""
        try:
            # Hide main window temporarily to avoid interference
            self.app.root.withdraw()
            
            # Get region using visual selector
            region = self.region_selector.select_region()
            
            # Show main window again
            self.app.root.deiconify()
            
            if region:
                x, y, width, height = region
                self._add_region_with_coords(x, y, width, height)
            else:
                self.app.messages(2, 2, "Region selection cancelled")
                
        except Exception as e:
            self.app.root.deiconify()  # Ensure window is shown even on error
            self.app.messages(2, 3, f"Region selection failed: {e}")
            
    def _add_region_with_coords(self, x, y, width, height):
#         from ocr_modules.ui.ui_components import RegionDialog  # internal import removed
    
        dialog = RegionDialog(
            self.app.root,
            title="Add Screen Region",
            default_name=f"Region_{len(self.regions) + 1}",
            default_coords=(x, y, width, height)
        )
    
        result = dialog.show()
    
        if result:
            self.add_region(
                name=result['name'],
                x=x, y=y, width=width, height=height,
                patterns=result['patterns'],
                cooldown=result['cooldown'],
                color_profile=result['color_profile'],
                tts_messages=result['tts_messages'],
                capture_method=result.get('capture_method', 'auto')
            )
            self._refresh_regions_tree()
            self.app.messages(2, 9, f"Region '{result['name']}' added")

    def _add_manual_region_dialog(self):
        """Dialog for manual region entry using the enhanced dialog"""
#         from ocr_modules.ui.ui_components import RegionDialog  # internal import removed

        dialog = RegionDialog(
            self.app.root,
            title="Add Manual Region", 
            default_name=f"Region_{len(self.regions) + 1}",
            default_coords=(100, 100, 400, 200)  # Default coordinates for manual entry
        )

        result = dialog.show()

        if result:
            x, y, w, h = result['bounds']
            self.add_region(
                name=result['name'],
                x=x, y=y, width=w, height=h,
                patterns=result['patterns'],
                cooldown=result['cooldown'],
                color_profile=result['color_profile'],
                tts_messages=result['tts_messages'],
                capture_method=result['capture_method']
            )
            self._refresh_regions_tree()
            self.app.messages(2, 9, f"Region '{result['name']}' added")

    def _update_preview(self):
        """Update the region preview canvas with multi-monitor awareness"""
        if hasattr(self, 'preview_canvas'):
            self.preview_canvas.delete("all")
            
            canvas_width = self.preview_canvas.winfo_width()
            canvas_height = self.preview_canvas.winfo_height()
            
            if canvas_width > 10:
                try:
                    # Get monitor information
                    with mss.mss() as sct:
                        monitors = sct.monitors[1:]  # Skip the "all in one" monitor
                        
                    # Calculate total virtual screen size
                    all_left = min(monitor['left'] for monitor in monitors)
                    all_top = min(monitor['top'] for monitor in monitors)
                    all_right = max(monitor['left'] + monitor['width'] for monitor in monitors)
                    all_bottom = max(monitor['top'] + monitor['height'] for monitor in monitors)
                    
                    total_width = all_right - all_left
                    total_height = all_bottom - all_top
                    
                    # Scale factor for preview
                    scale_x = canvas_width / total_width
                    scale_y = canvas_height / total_height
                    scale = min(scale_x, scale_y) * 0.8
                    
                    # Calculate offset to center the preview
                    preview_width = total_width * scale
                    preview_height = total_height * scale
                    offset_x = (canvas_width - preview_width) / 2
                    offset_y = (canvas_height - preview_height) / 2
                    
                    # Draw each monitor
                    colors = ['lightgray', 'darkgray', 'lightblue', 'lightgreen']
                    for i, monitor in enumerate(monitors):
                        color = colors[i % len(colors)]
                        
                        # Scale monitor coordinates
                        mx = offset_x + (monitor['left'] - all_left) * scale
                        my = offset_y + (monitor['top'] - all_top) * scale
                        mw = monitor['width'] * scale
                        mh = monitor['height'] * scale
                        
                        # Draw monitor rectangle
                        self.preview_canvas.create_rectangle(
                            mx, my, mx + mw, my + mh,
                            outline='black', width=1, fill=color
                        )
                        
                        # Add monitor label
                        monitor_label = f"Monitor {i+1}"
                        if i == 0:
                            monitor_label += " (Primary)"
                        self.preview_canvas.create_text(
                            mx + 5, my + 15,
                            text=monitor_label,
                            fill='black',
                            font=("Arial", 7),
                            anchor=tk.W
                        )
                    
                    # Draw each region on the preview
                    region_colors = ['red', 'blue', 'green', 'orange', 'purple']
                    for i, region in enumerate(self.regions):
                        rx, ry, rw, rh = region['bounds']
                        color = region_colors[i % len(region_colors)]
                        
                        # For window regions with subregions, use the subregion bounds for display
                        if region.get('type') == 'window' and region.get('subregion_bounds'):
                            # Use subregion bounds instead of window bounds
                            sub_x, sub_y, sub_w, sub_h = region['subregion_bounds']
                            window_x, window_y, window_w, window_h = region['bounds']
        
                                    # Calculate absolute coordinates of subregion
                            abs_x = window_x + sub_x
                            abs_y = window_y + sub_y
                            x, y, width, height = abs_x, abs_y, sub_w, sub_h
        
                            # Add subregion indicator to the region name
                            region_display_name = f"{region['name']} (Subregion)"
                        else:
                            # Use regular bounds
                            x, y, width, height = region['bounds']
                            region_display_name = region['name']
                        
                        # Scale region coordinates
                        px = offset_x + (rx - all_left) * scale
                        py = offset_y + (ry - all_top) * scale
                        pw = rw * scale
                        ph = rh * scale
                        
                        # Only draw if region is visible in preview
                        if (px < canvas_width and py < canvas_height and 
                            px + pw > 0 and py + ph > 0):
                            
                            # Draw region rectangle
                            self.preview_canvas.create_rectangle(
                                px, py, px + pw, py + ph,
                                outline=color, width=2, fill='', stipple='gray50'
                            )
                            
                            # Add region name if space permits
                            if pw > 30 and ph > 15:
                                self.preview_canvas.create_text(
                                    px + pw/2, py + ph/2,
                                    text=region['name'],
                                    fill=color,
                                    font=("Arial", 6),
                                    angle=45
                                )
                                
                except Exception as e:
                    print(f"Error updating preview: {e}")
                    # Fallback to simple preview
                    self._fallback_preview()

    def _fallback_preview(self):
        """Fallback preview for single monitor"""
        canvas_width = self.preview_canvas.winfo_width()
        canvas_height = self.preview_canvas.winfo_height()
        
        if canvas_width > 10:
            # Simple rectangle representing primary monitor
            monitor_rect = self.preview_canvas.create_rectangle(
                10, 10, canvas_width - 10, canvas_height - 10,
                outline='gray', width=1
            )
            
            # Draw regions as small rectangles
            for i, region in enumerate(self.regions):
                # Simplified representation - just show relative position
                color = ['red', 'blue', 'green', 'orange', 'purple'][i % 5]
                
                # Use first 2 digits of coordinates for positioning
                x = 10 + (region['bounds'][0] % 90) * (canvas_width - 20) / 100
                y = 10 + (region['bounds'][1] % 90) * (canvas_height - 20) / 100
                w = 20
                h = 15
                
                self.preview_canvas.create_rectangle(
                    x, y, x + w, y + h,
                    outline=color, width=1, fill=color, stipple='gray50'
                )

    def _refresh_regions_tree(self):
        """Refresh the regions treeview with context menu support"""
        if not hasattr(self, 'regions_tree') or self.regions_tree is None:
            return

        try:
            if not self.regions_tree.winfo_exists():
                return

            # Clear existing items
            for item in self.regions_tree.get_children():
                self.regions_tree.delete(item)

            # Populate with regions
            for region in self.regions:
                if region.get('hwnd') and not region.get('type'):
                    region['type'] = 'window'
                    print(f"DEBUG: Auto-set type='window' for region: {region['name']}")
                # Format bounds based on region type
                if region.get('type') == 'window':
                    bounds_str = "Dynamic (Window)"
                    region_type = f"Window: {region.get('window_title', 'Unknown')}"
                    # Add subregion info if exists
                    if region.get('subregion_bounds'):
                        sub_x, sub_y, sub_w, sub_h = region['subregion_bounds']
                        bounds_str = f"Subregion: {sub_w}x{sub_h} at ({sub_x},{sub_y})"
                        region_type += " + Subregion"
                    # Try to get current window position
                    current_hwnd = self.find_best_window_match(region)
                    if current_hwnd:
                        try:
                            left, top, right, bottom = win32gui.GetWindowRect(current_hwnd)
                            bounds_str = f"{left},{top},{right-left},{bottom-top}"
                        except:
                            bounds_str = "Window found"
                    else:
                        bounds_str = "Window not found"
                else:
                    bounds_str = f"{region['bounds'][0]},{region['bounds'][1]},{region['bounds'][2]},{region['bounds'][3]}"
                    region_type = "Screen Region"

                # Format patterns for display
                patterns_str = ", ".join(region['patterns'][:2])
                if len(region['patterns']) > 2:
                    patterns_str += f" (+{len(region['patterns']) - 2} more)"

                # TTS info
                tts_count = len(region.get('tts_messages', {}))
                tts_info = f"{tts_count} custom" if tts_count > 0 else "Default"

                # Capture method
                capture_method = region.get('capture_method', self.config.get("capture_method", "auto"))
            
                # Monitor info
                monitor_info = self._get_monitor_info(region.get('bounds', (0, 0, 100, 100)))

                # Insert with status color coding
                tags = (region['name'],)
                if not region.get('enabled', True):
                    tags += ('disabled',)
                elif region.get('type') == 'window' and not self.find_best_window_match(region):
                    tags += ('window_not_found',)

                self.regions_tree.insert('', tk.END, values=(
                    region['name'],
                    bounds_str,
                    patterns_str,
                    "Yes" if region.get('enabled', True) else "No",
                    monitor_info,
                    tts_info,
                    capture_method,
                    region_type
                ), tags=tags)

            # Configure tag styles
            self.regions_tree.tag_configure('disabled', foreground='gray')
            self.regions_tree.tag_configure('window_not_found', foreground='orange')

            # Add context menu
            self._setup_treeview_context_menu()

            # Refresh related trees
            if hasattr(self, 'region_methods_tree'):
                self._refresh_region_methods_tree()

            # Update preview
            if hasattr(self, 'preview_canvas'):
                self.app.root.after(100, self._update_preview)

        except tk.TclError as e:
            print(f"Regions tree no longer exists: {e}")

    def _setup_treeview_context_menu(self):
        """Setup right-click context menu for regions treeview"""
        if not hasattr(self, 'regions_context_menu'):
            self.regions_context_menu = tk.Menu(self.regions_tree, tearoff=0)

            self.regions_context_menu.add_command(
                label="Test Region", 
                command=self._test_region
            )
            self.regions_context_menu.add_command(
                label="Edit Region", 
                command=self._edit_region  # This should call the fixed _edit_region method
            )
            self.regions_context_menu.add_command(
                label="Toggle Enabled", 
                command=self._toggle_region
            )
            self.regions_context_menu.add_separator()
            self.regions_context_menu.add_command(
                label="Configure TTS", 
                command=self._configure_region_tts
            )
            self.regions_context_menu.add_command(
                label="Color Picker", 
                command=self._open_color_picker_for_region
            )
            self.regions_context_menu.add_separator()
            self.regions_context_menu.add_command(
                label="Remove Region", 
                command=self._remove_region
            )

        def show_context_menu(event):
            item = self.regions_tree.identify_row(event.y)
            if item:
                self.regions_tree.selection_set(item)
                self.regions_context_menu.post(event.x_root, event.y_root)
    
        self.regions_tree.bind("<Button-3>", show_context_menu)

    def _configure_region_tts(self):
        """Configure TTS messages for selected region"""
        selection = self.regions_tree.selection()
        if selection:
            region_name = self.regions_tree.item(selection[0], 'tags')[0]
            region = next((r for r in self.regions if r['name'] == region_name), None)
        
            if region:
                dialog = PatternTTSDialog(
                    self.app.root, 
                    region['patterns'], 
                    region.get('tts_messages', {})
                )
                result = dialog.show()
            
                if result is not None:
                    region['tts_messages'] = result
                    self.ensure_save()
                    self._refresh_regions_tree()
                    self.app.messages(2, 9, f"TTS messages updated for '{region_name}'")

    def _get_monitor_info(self, bounds):
        """Get which monitor the region is on"""
        x, y, w, h = bounds
        center_x = x + w // 2
        center_y = y + h // 2
        
        # This is a simplified version - you might want to use screeninfo library
        # for more accurate multi-monitor detection
        screen_width = pyautogui.size().width
        screen_height = pyautogui.size().height
        
        if center_x <= screen_width and center_y <= screen_height:
            return "Primary"
        else:
            return "Secondary"
       
    def _browse_tesseract(self):
        """Browse for Tesseract executable"""
        filename = filedialog.askopenfilename(
            title="Select Tesseract Executable",
            filetypes=[("Executable files", "*.exe"), ("All files", "*.*")],
            initialfile="tesseract.exe"
        )
        if filename:
            self.tesseract_path_var.set(filename)
            
    def _test_tesseract(self):
        """Test Tesseract installation"""
        path = self.tesseract_path_var.get()
        if path and Path(path).exists():
            pytesseract.pytesseract.tesseract_cmd = path
            
        try:
            version = pytesseract.get_tesseract_version()
            self.tesseract_status_var.set(f"âœ“ Tesseract {version} working correctly")
            # Update config
            self.config["tesseract_path"] = path
        except Exception as e:
            self.tesseract_status_var.set(f"âœ— Tesseract error: {e}")

    def _add_region_dialog(self):
        """Add region using simplified embedded patterns dialog"""
#         from ocr_modules.ui.ui_components import RegionDialog  # internal import removed
    
        dialog = RegionDialog(
            self.app.root,
            title="Add Screen Region",
            default_name=f"Region_{len(self.regions) + 1}",
            default_coords=(100, 100, 400, 200)
        )
    
        result = dialog.show()
    
        if result:
            self.add_region(
                name=result['name'],
                x=result['bounds'][0], y=result['bounds'][1],
                width=result['bounds'][2], height=result['bounds'][3],
                patterns=result['patterns'],
                cooldown=result['cooldown'],
                color_profile=result['color_profile'],
                tts_messages=result['tts_messages'],
                capture_method=result['capture_method']
            )
            self._refresh_regions_tree()
            self.app.messages(2, 9, f"Region '{result['name']}' added")

    def _add_window_region_dialog(self):
        """Add window region using the new unified dialog"""
#         from ocr_modules.ui.ui_components import WindowRegionDialog  # internal import removed
    
        dialog = WindowRegionDialog(
            self.app.root,
            title="Add Window Region",
            default_name=f"Window_{len(self.regions) + 1}"
        )

        result = dialog.show()
    
        if result:
            # Use the existing add_window_region method but with the new data structure
            region = self.add_window_region(
                name=result['name'],
                hwnd=result['hwnd'],
                window_title=result['window_title'],
                capture_method=result['capture_method'],
                patterns=result['patterns'],
                cooldown=result['cooldown'],
                subregion_bounds=result.get('subregion_bounds')  # Make sure this is included
            )
            # Update additional fields that might be in the result
            if 'color_profile' in result:
                region['color_profile'] = result['color_profile']
            if 'tts_messages' in result:
                region['tts_messages'] = result['tts_messages']
            if 'process_name' in result:
                region['process_name'] = result['process_name']

            self._refresh_regions_tree()
            self.app.messages(2, 9, f"Window region '{result['name']}' added")

    def _edit_window_region(self, region):
        """Edit window region using the new unified dialog"""
        print(f"DEBUG: Editing window region '{region['name']}'")
        print(f"DEBUG: Region data: {region}")
        print(f"DEBUG: Subregion bounds in region: {region.get('subregion_bounds')}")
#         from ocr_modules.ui.ui_components import WindowRegionDialog  # internal import removed
    
        dialog = WindowRegionDialog(
            self.app.root,
            title=f"Edit Window Region - {region['name']}",
            default_name=region['name'],
            existing_region=region  # Make sure this is passed correctly
        )
    
        result = dialog.show()
    
        if result:
            # Update the region with ALL new values including subregion
            region.update({
                'name': result['name'],
                'window_title': result['window_title'],
                'process_name': result.get('process_name', region.get('process_name', '')),
                'patterns': result['patterns'],
                'cooldown': result['cooldown'],
                'color_profile': result.get('color_profile', 'default'),
                'tts_messages': result.get('tts_messages', {}),
                'capture_method': result['capture_method'],
                'subregion_bounds': result.get('subregion_bounds')  # CRITICAL: Update subregion
            })
            self.ensure_save()
            self._refresh_regions_tree()
            self.app.messages(2, 9, f"Window region '{result['name']}' updated")

    def _edit_region(self):
        """Edit selected region - FIXED to handle window regions properly"""
        selection = self.regions_tree.selection()
        if selection:
            region_name = self.regions_tree.item(selection[0], 'tags')[0]
            region = next((r for r in self.regions if r['name'] == region_name), None)

            if region:
                # Check if this is a window region and call the appropriate editor
                if region.get('type') == 'window':
                    print(f"DEBUG: Editing WINDOW region: {region['name']}")
                    self._edit_window_region(region)
                else:
                    print(f"DEBUG: Editing SCREEN region: {region['name']}")
                    self._edit_region_dialog(region)
            else:
                messagebox.showwarning("Error", "Region not found")
        else:
            messagebox.showwarning("No Selection", "Please select a region to edit")

    def _edit_region_dialog(self, region):
        """Edit region using simplified embedded patterns dialog"""
#         from ocr_modules.ui.ui_components import RegionDialog  # internal import removed
    
        dialog = RegionDialog(
            self.app.root,
            title=f"Edit Region - {region['name']}",
            default_name=region['name'],
            default_coords=region.get('bounds'),
            is_edit_mode=True,
            existing_region=region
        )
    
        result = dialog.show()

        if result:
            # Update region with new values
            region.update(result)
            self.ensure_save()
            self._refresh_regions_tree()
            self.app.messages(2, 9, f"Region '{result['name']}' updated")

    def _test_single_region(self, region):
        """Test a specific region"""
        try:
            if region.get('hwnd'):
                # Window capture
                self.window_capture.set_method(region.get('capture_method', 'auto'))
                image = self.window_capture.capture_region(hwnd=region['hwnd'])
            else:
                # Screen region capture
                x, y, w, h = region['bounds']
                region_dict = {'left': x, 'top': y, 'width': w, 'height': h}
                self.window_capture.set_method(region.get('capture_method', 'auto'))
                image = self.window_capture.capture_region(region=region_dict)
            
            if image:
                # Show preview
                preview = tk.Toplevel(self.app.root)
                preview.title(f"Test - {region['name']}")
                
                # Resize for display
                display_width = min(image.width, 600)
                scale_factor = display_width / image.width
                display_height = int(image.height * scale_factor)
                
                display_image = image.resize((display_width, display_height), Image.LANCZOS)
                photo = ImageTk.PhotoImage(display_image)
                
                label = ttk.Label(preview, image=photo)
                label.image = photo
                label.pack(padx=10, pady=10)
                
                # Perform OCR on the test image
                processed_image = self.preprocess_image_for_gaming(image, region['name'])
                ocr_config = self._get_ocr_config()
                text = pytesseract.image_to_string(processed_image, config=ocr_config)
                
                # Show OCR results
                text_frame = ttk.Frame(preview)
                text_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
                
                ttk.Label(text_frame, text="OCR Results:", font=("Arial", 10, "bold")).pack(anchor=tk.W)
                
                text_widget = tk.Text(text_frame, height=6, wrap=tk.WORD)
                text_scrollbar = ttk.Scrollbar(text_frame, orient=tk.VERTICAL, command=text_widget.yview)
                text_widget.configure(yscrollcommand=text_scrollbar.set)
                
                text_widget.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
                text_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
                
                text_widget.insert(1.0, text if text.strip() else "No text detected")
                text_widget.config(state=tk.DISABLED)
            else:
                messagebox.showerror("Test Failed", "Could not capture region")
                
        except Exception as e:
            messagebox.showerror("Test Failed", f"Error: {e}")

    def add_window_region(self, name, hwnd, window_title, capture_method, patterns, cooldown=300, subregion_bounds=None):
        """Add a window-based region with proper bounds and optional sub-region"""
        try:
            # Get current window bounds for display
            left, top, right, bottom = win32gui.GetWindowRect(hwnd)
            width = right - left
            height = bottom - top

            region = {
                'name': name,
                'type': 'window',
                'hwnd': hwnd,
                'window_title': window_title,
                'bounds': (left, top, width, height),  # Entire window bounds
                'patterns': patterns,
                'cooldown': cooldown or self.config.get("default_cooldown", 300),
                'last_seen': {},
                'enabled': True,
                'color_profile': self.config.get("current_color_profile", "default"),
                'tts_messages': {},
                'capture_method': capture_method,
                'subregion_bounds': subregion_bounds  # Can be None (entire window) or (x, y, w, h) relative to window
            }
            self.regions.append(region)
            self.ensure_save()

            return region
        except Exception as e:
            print(f"Error adding window region: {e}")
            # Fallback with default bounds
            region = {
                'name': name,
                'type': 'window', 
                'hwnd': hwnd,
                'window_title': window_title,
                'bounds': (0, 0, 100, 100),  # FALLBACK BOUNDS
                'patterns': patterns,
                'cooldown': cooldown,
                'last_seen': {},
                'enabled': True,
                'color_profile': self.config.get("current_color_profile", "default"),
                'tts_messages': {},
                'capture_method': capture_method,
                'subregion_bounds': subregion_bounds
            }
            self.regions.append(region)
            self.ensure_save()
            return region

    def find_window_by_criteria(self, window_title=None, process_name=None, window_class=None):
        """Find a window based on identification criteria"""
        try:
            windows = self.list_available_windows()

            for window in windows:
                matches = True

                # Match window title (partial match)
                if window_title:
                    if window_title.lower() not in window['title'].lower():
                        matches = False

                # Match process name (exact match)
                if process_name and matches:
                    if process_name.lower() != window['process_name'].lower():
                        matches = False

                # Match window class (exact match)
                if window_class and matches:
                    if window_class != window['class_name']:
                        matches = False

                if matches:
                    return window['hwnd']

            return None

        except Exception as e:
            print(f"Error finding window: {e}")
            return None

    def find_best_window_match(self, region):
        """Find the best matching window for a region"""
        # Try exact match first
        hwnd = self.find_window_by_criteria(
            window_title=region.get('window_title'),
            process_name=region.get('process_name'),
            window_class=region.get('window_class')
        )

        # If no exact match, try with just title and process
        if not hwnd and region.get('window_title') and region.get('process_name'):
            hwnd = self.find_window_by_criteria(
                window_title=region.get('window_title'),
                process_name=region.get('process_name')
            )

        # If still no match, try with just title
        if not hwnd and region.get('window_title'):
            hwnd = self.find_window_by_criteria(
                window_title=region.get('window_title')
            )

        return hwnd

    def _remove_region(self):
        """Remove selected region"""
        selection = self.regions_tree.selection()
        if selection:
            region_name = self.regions_tree.item(selection[0], 'tags')[0]
            self.remove_region(region_name)
            self._refresh_regions_tree()
            
    def _toggle_region(self):
        """Toggle region enabled state"""
        selection = self.regions_tree.selection()
        if selection:
            region_name = self.regions_tree.item(selection[0], 'tags')[0]
            for region in self.regions:
                if region['name'] == region_name:
                    region['enabled'] = not region.get('enabled', True)
                    break
            self._refresh_regions_tree()
            self.reset_monitoring_state()
            
    def _apply_ocr_settings(self):
        """Apply OCR settings from the UI"""
        try:
            self.config["check_interval"] = float(self.interval_var.get())
            self.config["language"] = self.language_var.get()
            self.config["default_cooldown"] = int(self.cooldown_var.get())
            self.config["tts_alerts"] = self.tts_alerts_var.get()
            self.config["not_alerts"] = self.not_alerts_var.get()
            
            self.app.messages(2, 9, "OCR settings applied")
            self.save_configuration()
            
        except ValueError as e:
            self.app.messages(2, 3, f"Invalid setting value: {e}")
            
    def reset_monitoring_state(self):
        """Reset monitoring state to clear any stuck data"""
        if self.monitoring:
            self.teardown()
            time.sleep(0.5)  # Brief pause
            self.setup()
        # Reset pattern tracking for all regions
        for region in self.regions:
            region['last_seen'] = {}
            region['last_region_alert'] = 0

    def list_available_windows(self):
        """List all available top-level windows with their details"""
        import psutil

        windows = []

        def enum_windows_proc(hwnd, lParam):
            if win32gui.IsWindowVisible(hwnd) and win32gui.GetWindowText(hwnd):
                _, pid = win32process.GetWindowThreadProcessId(hwnd)
                try:
                    process = psutil.Process(pid)
                    process_name = process.name()
                except:
                    process_name = "Unknown"

                window_title = win32gui.GetWindowText(hwnd)
                class_name = win32gui.GetClassName(hwnd)

                # Get window dimensions
                try:
                    left, top, right, bottom = win32gui.GetWindowRect(hwnd)
                    width = right - left
                    height = bottom - top

                    # Only include windows of reasonable size
                    if width > 100 and height > 100:
                        windows.append({
                            'hwnd': hwnd,
                            'title': window_title,
                            'class_name': class_name,
                            'pid': pid,
                            'process_name': process_name,
                            'bounds': (left, top, width, height),
                            'size': f"{width}x{height}"
                        })
                except:
                    pass  # Skip windows that can't be measured
            return True

        win32gui.EnumWindows(enum_windows_proc, None)
        return sorted(windows, key=lambda x: x['title'])

    def get_top_parent(self, hwnd):
        """Get the top-level parent window for a handle"""
        if not hwnd or not win32gui.IsWindow(hwnd):
            return None

        parent = win32gui.GetParent(hwnd)
        while parent:
            hwnd = parent
            parent = win32gui.GetParent(hwnd)
        return hwnd

    def _select_window_from_list(self):
        """Open the new unified window region dialog instead of the old one"""
        self._add_window_region_dialog()

    def _on_window_selected(self, tree, dialog):
        """Handle window selection from the list"""
        selection = tree.selection()
        if selection:
            hwnd = tree.item(selection[0], 'tags')[0]
            dialog.destroy()
            self._configure_selected_window(hwnd)
        else:
            messagebox.showwarning("No Selection", "Please select a window from the list.")

    def _configure_selected_window(self, hwnd):
        """Configure monitoring for a selected window using identification criteria"""
        try:
            # Get window information for identification
            window_title = win32gui.GetWindowText(hwnd)
            class_name = win32gui.GetClassName(hwnd)

            # Get process name
            _, pid = win32process.GetWindowThreadProcessId(hwnd)
            try:
                process = psutil.Process(pid)
                process_name = process.name()
            except:
                process_name = "Unknown"
        
            # Create configuration dialog
            dialog = tk.Toplevel(self.app.root)
            dialog.title(f"Configure Window: {window_title[:30]}...")
            dialog.geometry("500x500")
            dialog.transient(self.app.root)

            main_frame = ttk.Frame(dialog, padding=10)
            main_frame.pack(fill=tk.BOTH, expand=True)

            # Window information
            info_frame = ttk.LabelFrame(main_frame, text="Window Identification")
            info_frame.pack(fill=tk.X, pady=(0, 10))

            info_text = f"""Title: {window_title}
                        Process: {process_name}
                        Class: {class_name}
                        PID: {pid}

                        The window will be found dynamically using these criteria."""

            info_label = ttk.Label(info_frame, text=info_text, justify=tk.LEFT)
            info_label.pack(padx=10, pady=10, anchor=tk.W)

            # Region name
            ttk.Label(main_frame, text="Region Name:").pack(anchor=tk.W, pady=(10, 5))
            name_var = tk.StringVar(value=window_title[:30] or f"Window_{process_name}")
            ttk.Entry(main_frame, textvariable=name_var).pack(fill=tk.X, pady=(0, 10))

            # Identification criteria (allow user to customize)
            criteria_frame = ttk.LabelFrame(main_frame, text="Identification Criteria")
            criteria_frame.pack(fill=tk.X, pady=(0, 10))

            ttk.Label(criteria_frame, text="Window Title:").pack(anchor=tk.W, pady=(5, 0))
            title_var = tk.StringVar(value=window_title)
            title_entry = ttk.Entry(criteria_frame, textvariable=title_var)
            title_entry.pack(fill=tk.X, padx=5, pady=(0, 5))

            ttk.Label(criteria_frame, text="Process Name:").pack(anchor=tk.W, pady=(5, 0))
            process_var = tk.StringVar(value=process_name)
            process_entry = ttk.Entry(criteria_frame, textvariable=process_var)
            process_entry.pack(fill=tk.X, padx=5, pady=(0, 5))

            ttk.Label(criteria_frame, text="Window Class (optional):").pack(anchor=tk.W, pady=(5, 0))
            class_var = tk.StringVar(value=class_name)
            class_entry = ttk.Entry(criteria_frame, textvariable=class_var)
            class_entry.pack(fill=tk.X, padx=5, pady=(0, 5))

            # Capture method
            ttk.Label(main_frame, text="Capture Method:").pack(anchor=tk.W, pady=(0, 5))
            method_var = tk.StringVar(value="auto")
            method_combo = ttk.Combobox(main_frame, textvariable=method_var,
                                    values=[method.value for method in CaptureMethod],
                                    state="readonly")
            method_combo.pack(fill=tk.X, pady=(0, 10))

            # Test capture button
            def test_capture():
                try:
                    self.window_capture.set_method(method_var.get())
                    image = self.window_capture.capture_region(hwnd=hwnd)

                    if image:
                        # Show preview
                        preview = tk.Toplevel(dialog)
                        preview.title("Capture Test")

                        display_width = min(image.width, 400)
                        scale_factor = display_width / image.width
                        display_height = int(image.height * scale_factor)

                        display_image = image.resize((display_width, display_height), Image.LANCZOS)
                        photo = ImageTk.PhotoImage(display_image)

                        label = ttk.Label(preview, image=photo)
                        label.image = photo
                        label.pack(padx=10, pady=10)

                        status = "âœ“ Capture successful!"
                        if image.getbbox() is None:
                            status = "âš  Warning: Image appears to be blank/black. Try a different capture method."

                        ttk.Label(preview, text=status).pack(pady=5)
                    else:
                        messagebox.showerror("Test Failed", "Failed to capture window")

                except Exception as e:
                    messagebox.showerror("Test Failed", f"Error: {str(e)}")

            ttk.Button(main_frame, text="Test Capture", 
                    command=test_capture).pack(anchor=tk.W, pady=(0, 10))

            # Patterns
            patterns_frame = ttk.LabelFrame(main_frame, text="Patterns to Monitor")
            patterns_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))

            patterns_text = tk.Text(patterns_frame, height=4)
            patterns_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            patterns_text.insert(1.0, "error\nwarning\nalert\nsuccess")

            def save_window_region():
                name = name_var.get().strip()
                if not name:
                    messagebox.showerror("Error", "Region name is required")
                    return

                patterns = [p.strip() for p in patterns_text.get(1.0, tk.END).strip().split('\n') if p.strip()]
                if not patterns:
                    messagebox.showerror("Error", "At least one pattern is required")
                    return

                # Add the window region using identification criteria
                self.add_window_region(
                    name=name,
                    hwnd=hwnd,  # Make sure hwnd is available here
                    window_title=title_var.get().strip(),
                    capture_method=method_var.get(),
                    patterns=patterns,
                    cooldown=300
                )

                dialog.destroy()
                self.app.messages(2, 9, f"Window region '{name}' added")

            ttk.Button(main_frame, text="Save Window Region", 
                    command=save_window_region, style='Success.TButton').pack(anchor=tk.E)

        except Exception as e:
            messagebox.showerror("Error", f"Failed to configure window: {e}")

    def _select_window_interactive(self):
        """Open the new unified window region dialog instead of the old one"""
        self._add_window_region_dialog()

    # Add these to your main class or a UI helper class
    def create_labeled_combobox(self, parent, label, values, default_value, callback=None):
        """Create a consistent labeled combobox"""
        frame = ttk.Frame(parent)
        frame.pack(fill=tk.X, pady=2)
    
        ttk.Label(frame, text=label).pack(side=tk.LEFT)
        var = tk.StringVar(value=default_value)
        combo = ttk.Combobox(frame, textvariable=var, values=values, state="readonly")
        combo.pack(side=tk.RIGHT, fill=tk.X, expand=True, padx=(10, 0))

        if callback:
            var.trace('w', callback)

        return var, combo

    def create_labeled_entry(self, parent, label, default_value, width=10):
        """Create a consistent labeled entry"""
        frame = ttk.Frame(parent)
        frame.pack(fill=tk.X, pady=2)

        ttk.Label(frame, text=label).pack(side=tk.LEFT)
        var = tk.StringVar(value=default_value)
        entry = ttk.Entry(frame, textvariable=var, width=width)
        entry.pack(side=tk.RIGHT, padx=(10, 0))

        return var

    def create_checkbox(self, parent, text, default_value, callback=None):
        """Create a consistent checkbox"""
        var = tk.BooleanVar(value=default_value)
        cb = ttk.Checkbutton(parent, text=text, variable=var)
        cb.pack(anchor=tk.W, pady=2)

        if callback:
            var.trace('w', callback)
        return var

    def ensure_save(self):
        """Ensure config is saved - call this after important changes"""
        try:
            self.config["regions"] = self.regions
            self.config_manager.save_configuration()
            print("âœ… Config saved")
            self._refresh_regions_tree()
        except Exception as e:
            print(f"âŒ Save failed: {e}")


# ==============================================================================
# File: ocr_modules\regions.py
# ==============================================================================

class RegionSelector:
    """Visual region selector with proper multi-monitor support and capture methods"""
    def __init__(self, app):
        self.app = app
        self.selector_window = None
        self.canvas = None
        self.start_x = None
        self.start_y = None
        self.rect = None
        self.screenshot = None
        self.photo = None
        self.selected_region = None
        self.selected_window = None  # NEW: Store window handle
        self.monitors = []
        self.capture_manager = WindowCapture()
        
        # NEW: Window selection mode
        self.window_selection_mode = False

        # Debug: Check what methods exist
        print("DEBUG: RegionSelector methods after init:")
        for attr_name in dir(self):
            if not attr_name.startswith('__'):
                print(f"  - {attr_name}")

    def select_window(self):
        """Select a specific window instead of screen region"""
        try:
            self.window_selection_mode = True
            self.app.root.withdraw()
            
            # Create window selection interface
            selector = tk.Toplevel()
            selector.attributes('-fullscreen', True)
            selector.attributes('-alpha', 0.3)
            selector.attributes('-topmost', True)
            selector.configure(cursor='crosshair')
            selector.configure(bg='blue')
            
            # Instructions
            label = tk.Label(selector, 
                           text="Click on the window you want to capture. Press ESC to cancel.",
                           font=("Arial", 16, "bold"), 
                           bg='blue', fg='white')
            label.place(relx=0.5, rely=0.1, anchor=tk.CENTER)
            
            def on_click(event):
                x, y = event.x_root, event.y_root
                hwnd = win32gui.WindowFromPoint((x, y))
                
                # Get window info
                window_text = win32gui.GetWindowText(hwnd)
                class_name = win32gui.GetClassName(hwnd)
                
                if hwnd and win32gui.IsWindowVisible(hwnd):
                    # Get window rect
                    left, top, right, bottom = win32gui.GetWindowRect(hwnd)
                    width = right - left
                    height = bottom - top
                    
                    # Store window info
                    self.selected_window = {
                        'hwnd': hwnd,
                        'title': window_text,
                        'class_name': class_name,
                        'bounds': (left, top, width, height)
                    }
                    
                    print(f"Selected window: {window_text} (Class: {class_name})")
                    print(f"Window bounds: {left}, {top}, {width}, {height}")
                    
                    selector.destroy()
                    self.app.root.deiconify()
                    
                    # Open window configuration dialog
                    self._configure_window_region()
                else:
                    messagebox.showwarning("Invalid Window", "Please select a valid visible window.")
            
            def cancel_selection(event=None):
                self.selected_window = None
                selector.destroy()
                self.app.root.deiconify()
            
            selector.bind('<Button-1>', on_click)
            selector.bind('<Escape>', cancel_selection)
            selector.focus_force()
            
        except Exception as e:
            print(f"Window selection error: {e}")
            self.app.root.deiconify()

    def _configure_window_region(self):
        """Configure region for a selected window"""
        if not self.selected_window:
            return
            
        dialog = tk.Toplevel(self.app.root)
        dialog.title("Configure Window Capture")
        dialog.geometry("500x400")
        dialog.transient(self.app.root)
        
        main_frame = ttk.Frame(dialog, padding=10)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Window info
        info_frame = ttk.LabelFrame(main_frame, text="Window Information")
        info_frame.pack(fill=tk.X, pady=(0, 10))
        
        info_text = tk.Text(info_frame, height=4, wrap=tk.WORD)
        info_text.pack(fill=tk.X, padx=5, pady=5)
        
        window_info = self.selected_window
        info_text.insert(1.0, 
            f"Window Title: {window_info['title']}\n"
            f"Class: {window_info['class_name']}\n"
            f"Handle: {window_info['hwnd']}\n"
            f"Bounds: {window_info['bounds']}"
        )
        info_text.config(state=tk.DISABLED)
        
        # Region name
        ttk.Label(main_frame, text="Region Name:").pack(anchor=tk.W, pady=(10, 5))
        name_var = tk.StringVar(value=window_info['title'][:30] or f"Window_{window_info['hwnd']}")
        ttk.Entry(main_frame, textvariable=name_var).pack(fill=tk.X, pady=(0, 10))
        
        # Capture method for window
        ttk.Label(main_frame, text="Capture Method:").pack(anchor=tk.W, pady=(0, 5))
        method_var = tk.StringVar(value="auto")
        method_combo = ttk.Combobox(main_frame, textvariable=method_var,
                                  values=[method.value for method in CaptureMethod],
                                  state="readonly")
        method_combo.pack(fill=tk.X, pady=(0, 10))
        
        # Test capture button
        def test_capture():
            try:
                self.capture_manager.set_method(method_var.get())
                image = self.capture_manager.capture_region(hwnd=window_info['hwnd'])
                if image:
                    # Show preview
                    preview = tk.Toplevel(dialog)
                    preview.title("Capture Test")
                    
                    # Resize for preview
                    display_width = min(image.width, 400)
                    scale_factor = display_width / image.width
                    display_height = int(image.height * scale_factor)
                    
                    preview_image = image.resize((display_width, display_height), Image.LANCZOS)
                    photo = ImageTk.PhotoImage(preview_image)
                    
                    label = ttk.Label(preview, image=photo)
                    label.image = photo
                    label.pack(padx=10, pady=10)
                    
                    ttk.Label(preview, text="If you see a black screen, try a different capture method.").pack(pady=5)
                else:
                    messagebox.showerror("Test Failed", "Failed to capture window")
            except Exception as e:
                messagebox.showerror("Test Failed", f"Error: {e}")
        
        ttk.Button(main_frame, text="Test Capture", command=test_capture).pack(anchor=tk.W, pady=(0, 10))
        
        # Patterns (same as before but for window)
        patterns_frame = ttk.LabelFrame(main_frame, text="Patterns to Monitor")
        patterns_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        patterns_text = tk.Text(patterns_frame, height=6)
        patterns_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        patterns_text.insert(1.0, "error\nwarning\nalert\ncritical")
        
        def save_window_region():
            name = name_var.get().strip()
            if not name:
                messagebox.showerror("Error", "Region name is required")
                return
                
            patterns = [p.strip() for p in patterns_text.get(1.0, tk.END).strip().split('\n') if p.strip()]
            if not patterns:
                messagebox.showerror("Error", "At least one pattern is required")
                return
            
            # Pass window info to the plugin
            if hasattr(self.app, 'plugins') and 'OCRMonitorPlugin' in self.app.plugins:
                plugin = self.app.plugins['OCRMonitorPlugin']
                plugin.add_window_region(
                    name=name,
                    hwnd=window_info['hwnd'],
                    window_title=window_info['title'],
                    capture_method=method_var.get(),
                    patterns=patterns,
                    cooldown=300
                )
                
            dialog.destroy()
            self.app.messages(2, 9, f"Window region '{name}' added")
        
        ttk.Button(main_frame, text="Save Window Region", 
                  command=save_window_region, style='Success.TButton').pack(anchor=tk.E)

    def capture_all_monitors(self):
        """Capture screenshot of all monitors combined using WindowCapture"""
        # Make sure we have monitor data
        if not self.monitors:
            self.get_all_monitors()
            
        try:
            # Calculate bounding box that contains all monitors
            all_left = min(monitor['left'] for monitor in self.monitors)
            all_top = min(monitor['top'] for monitor in self.monitors)
            all_right = max(monitor['right'] for monitor in self.monitors)
            all_bottom = max(monitor['bottom'] for monitor in self.monitors)
            
            total_width = all_right - all_left
            total_height = all_bottom - all_top
            
            print(f"DEBUG: Virtual screen bounds: left={all_left}, top={all_top}, right={all_right}, bottom={all_bottom}")
            print(f"DEBUG: Capturing virtual screen: {total_width}x{total_height}")
            
            # Use WindowCapture to capture the region
            region = {
                'left': all_left,
                'top': all_top, 
                'width': total_width,
                'height': total_height
            }
            
            return self.capture_manager.capture_region(region=region)
            
        except Exception as e:
            print(f"Error capturing all monitors: {e}")
            raise
        
    def select_region(self):
        """Open region selector covering all monitors"""
        try:
            # Get monitor information first
            self.get_all_monitors()
            
            # Capture screenshot of all monitors
            self.screenshot = self.capture_all_monitors()
            
            # Calculate virtual screen bounds
            all_left = min(monitor['left'] for monitor in self.monitors)
            all_top = min(monitor['top'] for monitor in self.monitors)
            all_right = max(monitor['right'] for monitor in self.monitors)
            all_bottom = max(monitor['bottom'] for monitor in self.monitors)
            
            total_width = all_right - all_left
            total_height = all_bottom - all_top
            
            # Create fullscreen selection window
            self.selector_window = tk.Toplevel(self.app.root)
            self.selector_window.attributes('-fullscreen', True)
            self.selector_window.attributes('-alpha', 0.7)
            self.selector_window.attributes('-topmost', True)
            self.selector_window.configure(cursor='crosshair')
            self.selector_window.configure(background='black')
            
            # Create canvas covering virtual screen
            self.canvas = tk.Canvas(self.selector_window, 
                                   width=total_width, 
                                   height=total_height,
                                   highlightthickness=0)
            self.canvas.pack(fill=tk.BOTH, expand=True)
            
            # Display screenshot
            self.photo = ImageTk.PhotoImage(self.screenshot)
            self.canvas.create_image(-all_left, -all_top, anchor=tk.NW, image=self.photo)
            
            # Draw monitor boundaries
            self._draw_monitor_boundaries(all_left, all_top)
            
            # Bind mouse events
            self.canvas.bind('<Button-1>', self.on_mouse_down)
            self.canvas.bind('<B1-Motion>', self.on_mouse_drag)
            self.canvas.bind('<ButtonRelease-1>', self.on_mouse_up)
            self.selector_window.bind('<Escape>', self.cancel_selection)
            
            # Instructions
            instructions = self.canvas.create_text(
                total_width // 2, 30,
                text="Drag to select region on any monitor. Press ESC to cancel.",
                fill="white",
                font=("Arial", 14, "bold"),
                justify=tk.CENTER
            )
            self.canvas.tag_raise(instructions)
            
            # Wait for selection
            self.selector_window.wait_window()
            return self.selected_region
            
        except Exception as e:
            print(f"Error in region selection: {e}")
            # Fallback to single monitor
            return self._fallback_select_region()
            
    def _draw_monitor_boundaries(self, offset_x, offset_y):
        """Draw boundaries around each monitor"""
        for i, monitor in enumerate(self.monitors):
            x1 = monitor['left'] - offset_x
            y1 = monitor['top'] - offset_y
            x2 = x1 + monitor['width']
            y2 = y1 + monitor['height']
            
            # Draw monitor border
            self.canvas.create_rectangle(
                x1, y1, x2, y2,
                outline='yellow', width=3, dash=(5, 5)
            )
            
            # Add monitor label
            monitor_text = f"Monitor {i}"
            if i == 1:  # Monitor 1 is typically the primary
                monitor_text += " (Primary)"
                
            self.canvas.create_text(
                x1 + 10, y1 + 20,
                text=monitor_text,
                fill="yellow",
                font=("Arial", 10, "bold"),
                anchor=tk.W
            )
            
    def _fallback_select_region(self):
        """Fallback method using pyautogui (single monitor only)"""
        print("DEBUG: Using fallback single-monitor selection")
        try:
            self.screenshot = pyautogui.screenshot()
            
            # Create fullscreen selection window
            self.selector_window = tk.Toplevel(self.app.root)
            self.selector_window.attributes('-fullscreen', True)
            self.selector_window.attributes('-alpha', 0.7)
            self.selector_window.attributes('-topmost', True)
            self.selector_window.configure(cursor='crosshair')
            
            screen_width = self.screenshot.width
            screen_height = self.screenshot.height
            
            self.canvas = tk.Canvas(self.selector_window, 
                                   width=screen_width, 
                                   height=screen_height,
                                   highlightthickness=0)
            self.canvas.pack(fill=tk.BOTH, expand=True)
            
            # Display screenshot
            self.photo = ImageTk.PhotoImage(self.screenshot)
            self.canvas.create_image(0, 0, anchor=tk.NW, image=self.photo)
            
            # Bind mouse events
            self.canvas.bind('<Button-1>', self.on_mouse_down)
            self.canvas.bind('<B1-Motion>', self.on_mouse_drag)
            self.canvas.bind('<ButtonRelease-1>', self.on_mouse_up)
            self.selector_window.bind('<Escape>', self.cancel_selection)
            
            # Instructions
            self.canvas.create_text(
                screen_width // 2, 30,
                text="Drag to select region (Single monitor mode). Press ESC to cancel.",
                fill="white",
                font=("Arial", 14, "bold"),
                justify=tk.CENTER
            )
            
            # Wait for selection
            self.selector_window.wait_window()
            return self.selected_region
            
        except Exception as e:
            print(f"Error in fallback region selection: {e}")
            return None
        
    def on_mouse_down(self, event):
        """Start region selection"""
        self.start_x = event.x
        self.start_y = event.y
        self.rect = self.canvas.create_rectangle(
            self.start_x, self.start_y, self.start_x, self.start_y,
            outline='red', width=2, fill='', stipple='gray50'
        )
        
    def on_mouse_drag(self, event):
        """Update selection rectangle"""
        if self.rect:
            self.canvas.coords(self.rect, self.start_x, self.start_y, event.x, event.y)
            
    def on_mouse_up(self, event):
        """Finish region selection"""
        if self.rect:
            # Get final coordinates
            x1, y1, x2, y2 = self.canvas.coords(self.rect)
            
            # Ensure positive width and height
            x = min(x1, x2)
            y = min(y1, y2)
            width = abs(x2 - x1)
            height = abs(y2 - y1)
            
            # Only accept regions larger than 10x10 pixels
            if width > 10 and height > 10:
                # Convert canvas coordinates to screen coordinates
                screen_x, screen_y = self._canvas_to_screen(x, y)
                
                self.selected_region = (int(screen_x), int(screen_y), int(width), int(height))
                
                # Draw final confirmation
                self.canvas.create_rectangle(
                    x, y, x + width, y + height,
                    outline='lime', width=3, fill='', stipple='gray25'
                )
                
                # Add coordinates text
                coords_text = f"Region: {int(screen_x)}, {int(screen_y)}, {int(width)}, {int(height)}"
                self.canvas.create_text(
                    x + width // 2, y + height + 20,
                    text=coords_text,
                    fill="lime",
                    font=("Arial", 10, "bold")
                )
                
                # Determine which monitor this region is on
                monitor_info = self._get_region_monitor(screen_x, screen_y, width, height)
                self.canvas.create_text(
                    x + width // 2, y + height + 40,
                    text=f"On: {monitor_info}",
                    fill="cyan",
                    font=("Arial", 9, "bold")
                )
                
                # Wait a moment so user can see the selection
                self.selector_window.after(1000, self.selector_window.destroy)
            else:
                messagebox.showwarning("Region too small", "Please select a larger region")
                self.cancel_selection()
                
    def _canvas_to_screen(self, canvas_x, canvas_y):
        """Convert canvas coordinates to actual screen coordinates"""
        # For multi-monitor setup with mss, we need to account for the virtual screen offset
        if hasattr(self, 'monitors') and self.monitors:
            all_left = min(monitor['left'] for monitor in self.monitors)
            all_top = min(monitor['top'] for monitor in self.monitors)
            screen_x = canvas_x + all_left
            screen_y = canvas_y + all_top
        else:
            # Fallback for single monitor
            screen_x = canvas_x
            screen_y = canvas_y
            
        return screen_x, screen_y
        
    def _get_region_monitor(self, x, y, width, height):
        """Determine which monitor contains the selected region"""
        region_center_x = x + width // 2
        region_center_y = y + height // 2
        
        for i, monitor in enumerate(self.monitors):
            if (monitor['left'] <= region_center_x <= monitor['right'] and
                monitor['top'] <= region_center_y <= monitor['bottom']):
                monitor_type = "Primary" if i == 1 else f"Monitor {i}"
                return f"{monitor_type} ({monitor['width']}x{monitor['height']})"
                
        return "Unknown Monitor"
                
    def cancel_selection(self, event=None):
        """Cancel region selection"""
        self.selected_region = None
        if self.selector_window:
            self.selector_window.destroy()

    def capture_region_for_preview(self, region_coords):
        """Capture a specific region for preview using configured method"""
        try:
            x, y, width, height = region_coords
            region = {
                'left': x,
                'top': y,
                'width': width,
                'height': height
            }
            return self.capture_manager.capture_region(region=region)
        except Exception as e:
            print(f"Error capturing region for preview: {e}")
            return None

    def select_region_within_window(self, hwnd, window_bounds):
        """Select a region within a specific window"""
        try:
            import win32gui

            # Bring window to foreground for selection
            win32gui.SetForegroundWindow(hwnd)

            # Create selection window that covers only the target window
            selector = tk.Toplevel()
            selector.attributes('-fullscreen', True)
            selector.attributes('-alpha', 0.3)
            selector.configure(background='lightblue')
            selector.attributes('-topmost', True)
    
            # Position overlay to match window position and size
            x, y, width, height = window_bounds
            selector.geometry(f"{width}x{height}+{x}+{y}")

            canvas = tk.Canvas(selector, highlightthickness=0, cursor="crosshair")
            canvas.pack(fill=tk.BOTH, expand=True)

            # Draw window border
            canvas.create_rectangle(0, 0, width, height, outline='red', width=2)

            start_x, start_y = None, None
            rect = None
            selected_region = None

            def on_mouse_press(event):
                nonlocal start_x, start_y, rect
                start_x, start_y = event.x, event.y
                rect = canvas.create_rectangle(start_x, start_y, start_x, start_y, 
                                            outline='yellow', width=2, fill='blue', stipple='gray50')

            def on_mouse_drag(event):
                nonlocal rect
                if rect:
                    canvas.coords(rect, start_x, start_y, event.x, event.y)

            def on_mouse_release(event):
                nonlocal start_x, start_y, selected_region
                if start_x is not None:
                    end_x, end_y = event.x, event.y

                    # Normalize coordinates
                    x1 = min(start_x, end_x)
                    y1 = min(start_y, end_y)
                    x2 = max(start_x, end_x)
                    y2 = max(start_y, end_y)

                    sel_width = x2 - x1
                    sel_height = y2 - y1

                    if sel_width > 10 and sel_height > 10:  # Minimum size
                        # Convert to screen coordinates
                        screen_x = x + x1
                        screen_y = y + y1

                        selected_region = (screen_x, screen_y, sel_width, sel_height)
                        selector.destroy()
                    else:
                        messagebox.showwarning("Too Small", "Please select a larger region.")
                        canvas.delete(rect)

            def on_escape(event):
                nonlocal selected_region
                selected_region = None
                selector.destroy()

            canvas.bind("<ButtonPress-1>", on_mouse_press)
            canvas.bind("<B1-Motion>", on_mouse_drag)
            canvas.bind("<ButtonRelease-1>", on_mouse_release)
            selector.bind("<Escape>", on_escape)

            selector.wait_window()
            return selected_region

        except Exception as e:
            print(f"Error selecting sub-region: {e}")
            return None
